/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case)]


pub const __GNUC_VA_LIST: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _CTYPE_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const BSTR_ERR: i32 = -1;
pub const BSTR_OK: u32 = 0;
pub const BSTR_BS_BUFF_LENGTH_GET: u32 = 0;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const REALLOC_FACTOR: f64 = 1.5;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const json_enable_comments: u32 = 1;
pub const json_error_max: u32 = 128;
pub const MD_FLAG_COLLAPSEWHITESPACE: u32 = 1;
pub const MD_FLAG_PERMISSIVEATXHEADERS: u32 = 2;
pub const MD_FLAG_PERMISSIVEURLAUTOLINKS: u32 = 4;
pub const MD_FLAG_PERMISSIVEEMAILAUTOLINKS: u32 = 8;
pub const MD_FLAG_NOINDENTEDCODEBLOCKS: u32 = 16;
pub const MD_FLAG_NOHTMLBLOCKS: u32 = 32;
pub const MD_FLAG_NOHTMLSPANS: u32 = 64;
pub const MD_FLAG_TABLES: u32 = 256;
pub const MD_FLAG_STRIKETHROUGH: u32 = 512;
pub const MD_FLAG_PERMISSIVEWWWAUTOLINKS: u32 = 1024;
pub const MD_FLAG_TASKLISTS: u32 = 2048;
pub const MD_FLAG_LATEXMATHSPANS: u32 = 4096;
pub const MD_FLAG_WIKILINKS: u32 = 8192;
pub const MD_FLAG_UNDERLINE: u32 = 16384;
pub const MD_FLAG_PERMISSIVEAUTOLINKS: u32 = 1036;
pub const MD_FLAG_NOHTML: u32 = 96;
pub const MD_DIALECT_COMMONMARK: u32 = 0;
pub const MD_DIALECT_GITHUB: u32 = 3852;
pub const SQLITE_VERSION: &'static [u8; 7usize] = b"3.39.3\0";
pub const SQLITE_VERSION_NUMBER: u32 = 3039003;
pub const SQLITE_SOURCE_ID: &'static [u8; 85usize] =
    b"2022-09-05 11:02:23 4635f4a69c8c2a8df242b384a992aea71224e39a2ccab42d8c0b0602f1e8alt1\0";
pub const SQLITE_OK: u32 = 0;
pub const SQLITE_ERROR: u32 = 1;
pub const SQLITE_INTERNAL: u32 = 2;
pub const SQLITE_PERM: u32 = 3;
pub const SQLITE_ABORT: u32 = 4;
pub const SQLITE_BUSY: u32 = 5;
pub const SQLITE_LOCKED: u32 = 6;
pub const SQLITE_NOMEM: u32 = 7;
pub const SQLITE_READONLY: u32 = 8;
pub const SQLITE_INTERRUPT: u32 = 9;
pub const SQLITE_IOERR: u32 = 10;
pub const SQLITE_CORRUPT: u32 = 11;
pub const SQLITE_NOTFOUND: u32 = 12;
pub const SQLITE_FULL: u32 = 13;
pub const SQLITE_CANTOPEN: u32 = 14;
pub const SQLITE_PROTOCOL: u32 = 15;
pub const SQLITE_EMPTY: u32 = 16;
pub const SQLITE_SCHEMA: u32 = 17;
pub const SQLITE_TOOBIG: u32 = 18;
pub const SQLITE_CONSTRAINT: u32 = 19;
pub const SQLITE_MISMATCH: u32 = 20;
pub const SQLITE_MISUSE: u32 = 21;
pub const SQLITE_NOLFS: u32 = 22;
pub const SQLITE_AUTH: u32 = 23;
pub const SQLITE_FORMAT: u32 = 24;
pub const SQLITE_RANGE: u32 = 25;
pub const SQLITE_NOTADB: u32 = 26;
pub const SQLITE_NOTICE: u32 = 27;
pub const SQLITE_WARNING: u32 = 28;
pub const SQLITE_ROW: u32 = 100;
pub const SQLITE_DONE: u32 = 101;
pub const SQLITE_ERROR_MISSING_COLLSEQ: u32 = 257;
pub const SQLITE_ERROR_RETRY: u32 = 513;
pub const SQLITE_ERROR_SNAPSHOT: u32 = 769;
pub const SQLITE_IOERR_READ: u32 = 266;
pub const SQLITE_IOERR_SHORT_READ: u32 = 522;
pub const SQLITE_IOERR_WRITE: u32 = 778;
pub const SQLITE_IOERR_FSYNC: u32 = 1034;
pub const SQLITE_IOERR_DIR_FSYNC: u32 = 1290;
pub const SQLITE_IOERR_TRUNCATE: u32 = 1546;
pub const SQLITE_IOERR_FSTAT: u32 = 1802;
pub const SQLITE_IOERR_UNLOCK: u32 = 2058;
pub const SQLITE_IOERR_RDLOCK: u32 = 2314;
pub const SQLITE_IOERR_DELETE: u32 = 2570;
pub const SQLITE_IOERR_BLOCKED: u32 = 2826;
pub const SQLITE_IOERR_NOMEM: u32 = 3082;
pub const SQLITE_IOERR_ACCESS: u32 = 3338;
pub const SQLITE_IOERR_CHECKRESERVEDLOCK: u32 = 3594;
pub const SQLITE_IOERR_LOCK: u32 = 3850;
pub const SQLITE_IOERR_CLOSE: u32 = 4106;
pub const SQLITE_IOERR_DIR_CLOSE: u32 = 4362;
pub const SQLITE_IOERR_SHMOPEN: u32 = 4618;
pub const SQLITE_IOERR_SHMSIZE: u32 = 4874;
pub const SQLITE_IOERR_SHMLOCK: u32 = 5130;
pub const SQLITE_IOERR_SHMMAP: u32 = 5386;
pub const SQLITE_IOERR_SEEK: u32 = 5642;
pub const SQLITE_IOERR_DELETE_NOENT: u32 = 5898;
pub const SQLITE_IOERR_MMAP: u32 = 6154;
pub const SQLITE_IOERR_GETTEMPPATH: u32 = 6410;
pub const SQLITE_IOERR_CONVPATH: u32 = 6666;
pub const SQLITE_IOERR_VNODE: u32 = 6922;
pub const SQLITE_IOERR_AUTH: u32 = 7178;
pub const SQLITE_IOERR_BEGIN_ATOMIC: u32 = 7434;
pub const SQLITE_IOERR_COMMIT_ATOMIC: u32 = 7690;
pub const SQLITE_IOERR_ROLLBACK_ATOMIC: u32 = 7946;
pub const SQLITE_IOERR_DATA: u32 = 8202;
pub const SQLITE_IOERR_CORRUPTFS: u32 = 8458;
pub const SQLITE_LOCKED_SHAREDCACHE: u32 = 262;
pub const SQLITE_LOCKED_VTAB: u32 = 518;
pub const SQLITE_BUSY_RECOVERY: u32 = 261;
pub const SQLITE_BUSY_SNAPSHOT: u32 = 517;
pub const SQLITE_BUSY_TIMEOUT: u32 = 773;
pub const SQLITE_CANTOPEN_NOTEMPDIR: u32 = 270;
pub const SQLITE_CANTOPEN_ISDIR: u32 = 526;
pub const SQLITE_CANTOPEN_FULLPATH: u32 = 782;
pub const SQLITE_CANTOPEN_CONVPATH: u32 = 1038;
pub const SQLITE_CANTOPEN_DIRTYWAL: u32 = 1294;
pub const SQLITE_CANTOPEN_SYMLINK: u32 = 1550;
pub const SQLITE_CORRUPT_VTAB: u32 = 267;
pub const SQLITE_CORRUPT_SEQUENCE: u32 = 523;
pub const SQLITE_CORRUPT_INDEX: u32 = 779;
pub const SQLITE_READONLY_RECOVERY: u32 = 264;
pub const SQLITE_READONLY_CANTLOCK: u32 = 520;
pub const SQLITE_READONLY_ROLLBACK: u32 = 776;
pub const SQLITE_READONLY_DBMOVED: u32 = 1032;
pub const SQLITE_READONLY_CANTINIT: u32 = 1288;
pub const SQLITE_READONLY_DIRECTORY: u32 = 1544;
pub const SQLITE_ABORT_ROLLBACK: u32 = 516;
pub const SQLITE_CONSTRAINT_CHECK: u32 = 275;
pub const SQLITE_CONSTRAINT_COMMITHOOK: u32 = 531;
pub const SQLITE_CONSTRAINT_FOREIGNKEY: u32 = 787;
pub const SQLITE_CONSTRAINT_FUNCTION: u32 = 1043;
pub const SQLITE_CONSTRAINT_NOTNULL: u32 = 1299;
pub const SQLITE_CONSTRAINT_PRIMARYKEY: u32 = 1555;
pub const SQLITE_CONSTRAINT_TRIGGER: u32 = 1811;
pub const SQLITE_CONSTRAINT_UNIQUE: u32 = 2067;
pub const SQLITE_CONSTRAINT_VTAB: u32 = 2323;
pub const SQLITE_CONSTRAINT_ROWID: u32 = 2579;
pub const SQLITE_CONSTRAINT_PINNED: u32 = 2835;
pub const SQLITE_CONSTRAINT_DATATYPE: u32 = 3091;
pub const SQLITE_NOTICE_RECOVER_WAL: u32 = 283;
pub const SQLITE_NOTICE_RECOVER_ROLLBACK: u32 = 539;
pub const SQLITE_WARNING_AUTOINDEX: u32 = 284;
pub const SQLITE_AUTH_USER: u32 = 279;
pub const SQLITE_OK_LOAD_PERMANENTLY: u32 = 256;
pub const SQLITE_OK_SYMLINK: u32 = 512;
pub const SQLITE_OPEN_READONLY: u32 = 1;
pub const SQLITE_OPEN_READWRITE: u32 = 2;
pub const SQLITE_OPEN_CREATE: u32 = 4;
pub const SQLITE_OPEN_DELETEONCLOSE: u32 = 8;
pub const SQLITE_OPEN_EXCLUSIVE: u32 = 16;
pub const SQLITE_OPEN_AUTOPROXY: u32 = 32;
pub const SQLITE_OPEN_URI: u32 = 64;
pub const SQLITE_OPEN_MEMORY: u32 = 128;
pub const SQLITE_OPEN_MAIN_DB: u32 = 256;
pub const SQLITE_OPEN_TEMP_DB: u32 = 512;
pub const SQLITE_OPEN_TRANSIENT_DB: u32 = 1024;
pub const SQLITE_OPEN_MAIN_JOURNAL: u32 = 2048;
pub const SQLITE_OPEN_TEMP_JOURNAL: u32 = 4096;
pub const SQLITE_OPEN_SUBJOURNAL: u32 = 8192;
pub const SQLITE_OPEN_SUPER_JOURNAL: u32 = 16384;
pub const SQLITE_OPEN_NOMUTEX: u32 = 32768;
pub const SQLITE_OPEN_FULLMUTEX: u32 = 65536;
pub const SQLITE_OPEN_SHAREDCACHE: u32 = 131072;
pub const SQLITE_OPEN_PRIVATECACHE: u32 = 262144;
pub const SQLITE_OPEN_WAL: u32 = 524288;
pub const SQLITE_OPEN_NOFOLLOW: u32 = 16777216;
pub const SQLITE_OPEN_EXRESCODE: u32 = 33554432;
pub const SQLITE_OPEN_MASTER_JOURNAL: u32 = 16384;
pub const SQLITE_IOCAP_ATOMIC: u32 = 1;
pub const SQLITE_IOCAP_ATOMIC512: u32 = 2;
pub const SQLITE_IOCAP_ATOMIC1K: u32 = 4;
pub const SQLITE_IOCAP_ATOMIC2K: u32 = 8;
pub const SQLITE_IOCAP_ATOMIC4K: u32 = 16;
pub const SQLITE_IOCAP_ATOMIC8K: u32 = 32;
pub const SQLITE_IOCAP_ATOMIC16K: u32 = 64;
pub const SQLITE_IOCAP_ATOMIC32K: u32 = 128;
pub const SQLITE_IOCAP_ATOMIC64K: u32 = 256;
pub const SQLITE_IOCAP_SAFE_APPEND: u32 = 512;
pub const SQLITE_IOCAP_SEQUENTIAL: u32 = 1024;
pub const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: u32 = 2048;
pub const SQLITE_IOCAP_POWERSAFE_OVERWRITE: u32 = 4096;
pub const SQLITE_IOCAP_IMMUTABLE: u32 = 8192;
pub const SQLITE_IOCAP_BATCH_ATOMIC: u32 = 16384;
pub const SQLITE_LOCK_NONE: u32 = 0;
pub const SQLITE_LOCK_SHARED: u32 = 1;
pub const SQLITE_LOCK_RESERVED: u32 = 2;
pub const SQLITE_LOCK_PENDING: u32 = 3;
pub const SQLITE_LOCK_EXCLUSIVE: u32 = 4;
pub const SQLITE_SYNC_NORMAL: u32 = 2;
pub const SQLITE_SYNC_FULL: u32 = 3;
pub const SQLITE_SYNC_DATAONLY: u32 = 16;
pub const SQLITE_FCNTL_LOCKSTATE: u32 = 1;
pub const SQLITE_FCNTL_GET_LOCKPROXYFILE: u32 = 2;
pub const SQLITE_FCNTL_SET_LOCKPROXYFILE: u32 = 3;
pub const SQLITE_FCNTL_LAST_ERRNO: u32 = 4;
pub const SQLITE_FCNTL_SIZE_HINT: u32 = 5;
pub const SQLITE_FCNTL_CHUNK_SIZE: u32 = 6;
pub const SQLITE_FCNTL_FILE_POINTER: u32 = 7;
pub const SQLITE_FCNTL_SYNC_OMITTED: u32 = 8;
pub const SQLITE_FCNTL_WIN32_AV_RETRY: u32 = 9;
pub const SQLITE_FCNTL_PERSIST_WAL: u32 = 10;
pub const SQLITE_FCNTL_OVERWRITE: u32 = 11;
pub const SQLITE_FCNTL_VFSNAME: u32 = 12;
pub const SQLITE_FCNTL_POWERSAFE_OVERWRITE: u32 = 13;
pub const SQLITE_FCNTL_PRAGMA: u32 = 14;
pub const SQLITE_FCNTL_BUSYHANDLER: u32 = 15;
pub const SQLITE_FCNTL_TEMPFILENAME: u32 = 16;
pub const SQLITE_FCNTL_MMAP_SIZE: u32 = 18;
pub const SQLITE_FCNTL_TRACE: u32 = 19;
pub const SQLITE_FCNTL_HAS_MOVED: u32 = 20;
pub const SQLITE_FCNTL_SYNC: u32 = 21;
pub const SQLITE_FCNTL_COMMIT_PHASETWO: u32 = 22;
pub const SQLITE_FCNTL_WIN32_SET_HANDLE: u32 = 23;
pub const SQLITE_FCNTL_WAL_BLOCK: u32 = 24;
pub const SQLITE_FCNTL_ZIPVFS: u32 = 25;
pub const SQLITE_FCNTL_RBU: u32 = 26;
pub const SQLITE_FCNTL_VFS_POINTER: u32 = 27;
pub const SQLITE_FCNTL_JOURNAL_POINTER: u32 = 28;
pub const SQLITE_FCNTL_WIN32_GET_HANDLE: u32 = 29;
pub const SQLITE_FCNTL_PDB: u32 = 30;
pub const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: u32 = 31;
pub const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: u32 = 32;
pub const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: u32 = 33;
pub const SQLITE_FCNTL_LOCK_TIMEOUT: u32 = 34;
pub const SQLITE_FCNTL_DATA_VERSION: u32 = 35;
pub const SQLITE_FCNTL_SIZE_LIMIT: u32 = 36;
pub const SQLITE_FCNTL_CKPT_DONE: u32 = 37;
pub const SQLITE_FCNTL_RESERVE_BYTES: u32 = 38;
pub const SQLITE_FCNTL_CKPT_START: u32 = 39;
pub const SQLITE_FCNTL_EXTERNAL_READER: u32 = 40;
pub const SQLITE_FCNTL_CKSM_FILE: u32 = 41;
pub const SQLITE_GET_LOCKPROXYFILE: u32 = 2;
pub const SQLITE_SET_LOCKPROXYFILE: u32 = 3;
pub const SQLITE_LAST_ERRNO: u32 = 4;
pub const SQLITE_ACCESS_EXISTS: u32 = 0;
pub const SQLITE_ACCESS_READWRITE: u32 = 1;
pub const SQLITE_ACCESS_READ: u32 = 2;
pub const SQLITE_SHM_UNLOCK: u32 = 1;
pub const SQLITE_SHM_LOCK: u32 = 2;
pub const SQLITE_SHM_SHARED: u32 = 4;
pub const SQLITE_SHM_EXCLUSIVE: u32 = 8;
pub const SQLITE_SHM_NLOCK: u32 = 8;
pub const SQLITE_CONFIG_SINGLETHREAD: u32 = 1;
pub const SQLITE_CONFIG_MULTITHREAD: u32 = 2;
pub const SQLITE_CONFIG_SERIALIZED: u32 = 3;
pub const SQLITE_CONFIG_MALLOC: u32 = 4;
pub const SQLITE_CONFIG_GETMALLOC: u32 = 5;
pub const SQLITE_CONFIG_SCRATCH: u32 = 6;
pub const SQLITE_CONFIG_PAGECACHE: u32 = 7;
pub const SQLITE_CONFIG_HEAP: u32 = 8;
pub const SQLITE_CONFIG_MEMSTATUS: u32 = 9;
pub const SQLITE_CONFIG_MUTEX: u32 = 10;
pub const SQLITE_CONFIG_GETMUTEX: u32 = 11;
pub const SQLITE_CONFIG_LOOKASIDE: u32 = 13;
pub const SQLITE_CONFIG_PCACHE: u32 = 14;
pub const SQLITE_CONFIG_GETPCACHE: u32 = 15;
pub const SQLITE_CONFIG_LOG: u32 = 16;
pub const SQLITE_CONFIG_URI: u32 = 17;
pub const SQLITE_CONFIG_PCACHE2: u32 = 18;
pub const SQLITE_CONFIG_GETPCACHE2: u32 = 19;
pub const SQLITE_CONFIG_COVERING_INDEX_SCAN: u32 = 20;
pub const SQLITE_CONFIG_SQLLOG: u32 = 21;
pub const SQLITE_CONFIG_MMAP_SIZE: u32 = 22;
pub const SQLITE_CONFIG_WIN32_HEAPSIZE: u32 = 23;
pub const SQLITE_CONFIG_PCACHE_HDRSZ: u32 = 24;
pub const SQLITE_CONFIG_PMASZ: u32 = 25;
pub const SQLITE_CONFIG_STMTJRNL_SPILL: u32 = 26;
pub const SQLITE_CONFIG_SMALL_MALLOC: u32 = 27;
pub const SQLITE_CONFIG_SORTERREF_SIZE: u32 = 28;
pub const SQLITE_CONFIG_MEMDB_MAXSIZE: u32 = 29;
pub const SQLITE_DBCONFIG_MAINDBNAME: u32 = 1000;
pub const SQLITE_DBCONFIG_LOOKASIDE: u32 = 1001;
pub const SQLITE_DBCONFIG_ENABLE_FKEY: u32 = 1002;
pub const SQLITE_DBCONFIG_ENABLE_TRIGGER: u32 = 1003;
pub const SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: u32 = 1004;
pub const SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: u32 = 1005;
pub const SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE: u32 = 1006;
pub const SQLITE_DBCONFIG_ENABLE_QPSG: u32 = 1007;
pub const SQLITE_DBCONFIG_TRIGGER_EQP: u32 = 1008;
pub const SQLITE_DBCONFIG_RESET_DATABASE: u32 = 1009;
pub const SQLITE_DBCONFIG_DEFENSIVE: u32 = 1010;
pub const SQLITE_DBCONFIG_WRITABLE_SCHEMA: u32 = 1011;
pub const SQLITE_DBCONFIG_LEGACY_ALTER_TABLE: u32 = 1012;
pub const SQLITE_DBCONFIG_DQS_DML: u32 = 1013;
pub const SQLITE_DBCONFIG_DQS_DDL: u32 = 1014;
pub const SQLITE_DBCONFIG_ENABLE_VIEW: u32 = 1015;
pub const SQLITE_DBCONFIG_LEGACY_FILE_FORMAT: u32 = 1016;
pub const SQLITE_DBCONFIG_TRUSTED_SCHEMA: u32 = 1017;
pub const SQLITE_DBCONFIG_MAX: u32 = 1017;
pub const SQLITE_DENY: u32 = 1;
pub const SQLITE_IGNORE: u32 = 2;
pub const SQLITE_CREATE_INDEX: u32 = 1;
pub const SQLITE_CREATE_TABLE: u32 = 2;
pub const SQLITE_CREATE_TEMP_INDEX: u32 = 3;
pub const SQLITE_CREATE_TEMP_TABLE: u32 = 4;
pub const SQLITE_CREATE_TEMP_TRIGGER: u32 = 5;
pub const SQLITE_CREATE_TEMP_VIEW: u32 = 6;
pub const SQLITE_CREATE_TRIGGER: u32 = 7;
pub const SQLITE_CREATE_VIEW: u32 = 8;
pub const SQLITE_DELETE: u32 = 9;
pub const SQLITE_DROP_INDEX: u32 = 10;
pub const SQLITE_DROP_TABLE: u32 = 11;
pub const SQLITE_DROP_TEMP_INDEX: u32 = 12;
pub const SQLITE_DROP_TEMP_TABLE: u32 = 13;
pub const SQLITE_DROP_TEMP_TRIGGER: u32 = 14;
pub const SQLITE_DROP_TEMP_VIEW: u32 = 15;
pub const SQLITE_DROP_TRIGGER: u32 = 16;
pub const SQLITE_DROP_VIEW: u32 = 17;
pub const SQLITE_INSERT: u32 = 18;
pub const SQLITE_PRAGMA: u32 = 19;
pub const SQLITE_READ: u32 = 20;
pub const SQLITE_SELECT: u32 = 21;
pub const SQLITE_TRANSACTION: u32 = 22;
pub const SQLITE_UPDATE: u32 = 23;
pub const SQLITE_ATTACH: u32 = 24;
pub const SQLITE_DETACH: u32 = 25;
pub const SQLITE_ALTER_TABLE: u32 = 26;
pub const SQLITE_REINDEX: u32 = 27;
pub const SQLITE_ANALYZE: u32 = 28;
pub const SQLITE_CREATE_VTABLE: u32 = 29;
pub const SQLITE_DROP_VTABLE: u32 = 30;
pub const SQLITE_FUNCTION: u32 = 31;
pub const SQLITE_SAVEPOINT: u32 = 32;
pub const SQLITE_COPY: u32 = 0;
pub const SQLITE_RECURSIVE: u32 = 33;
pub const SQLITE_TRACE_STMT: u32 = 1;
pub const SQLITE_TRACE_PROFILE: u32 = 2;
pub const SQLITE_TRACE_ROW: u32 = 4;
pub const SQLITE_TRACE_CLOSE: u32 = 8;
pub const SQLITE_LIMIT_LENGTH: u32 = 0;
pub const SQLITE_LIMIT_SQL_LENGTH: u32 = 1;
pub const SQLITE_LIMIT_COLUMN: u32 = 2;
pub const SQLITE_LIMIT_EXPR_DEPTH: u32 = 3;
pub const SQLITE_LIMIT_COMPOUND_SELECT: u32 = 4;
pub const SQLITE_LIMIT_VDBE_OP: u32 = 5;
pub const SQLITE_LIMIT_FUNCTION_ARG: u32 = 6;
pub const SQLITE_LIMIT_ATTACHED: u32 = 7;
pub const SQLITE_LIMIT_LIKE_PATTERN_LENGTH: u32 = 8;
pub const SQLITE_LIMIT_VARIABLE_NUMBER: u32 = 9;
pub const SQLITE_LIMIT_TRIGGER_DEPTH: u32 = 10;
pub const SQLITE_LIMIT_WORKER_THREADS: u32 = 11;
pub const SQLITE_PREPARE_PERSISTENT: u32 = 1;
pub const SQLITE_PREPARE_NORMALIZE: u32 = 2;
pub const SQLITE_PREPARE_NO_VTAB: u32 = 4;
pub const SQLITE_INTEGER: u32 = 1;
pub const SQLITE_FLOAT: u32 = 2;
pub const SQLITE_BLOB: u32 = 4;
pub const SQLITE_NULL: u32 = 5;
pub const SQLITE_TEXT: u32 = 3;
pub const SQLITE3_TEXT: u32 = 3;
pub const SQLITE_UTF8: u32 = 1;
pub const SQLITE_UTF16LE: u32 = 2;
pub const SQLITE_UTF16BE: u32 = 3;
pub const SQLITE_UTF16: u32 = 4;
pub const SQLITE_ANY: u32 = 5;
pub const SQLITE_UTF16_ALIGNED: u32 = 8;
pub const SQLITE_DETERMINISTIC: u32 = 2048;
pub const SQLITE_DIRECTONLY: u32 = 524288;
pub const SQLITE_SUBTYPE: u32 = 1048576;
pub const SQLITE_INNOCUOUS: u32 = 2097152;
pub const SQLITE_WIN32_DATA_DIRECTORY_TYPE: u32 = 1;
pub const SQLITE_WIN32_TEMP_DIRECTORY_TYPE: u32 = 2;
pub const SQLITE_TXN_NONE: u32 = 0;
pub const SQLITE_TXN_READ: u32 = 1;
pub const SQLITE_TXN_WRITE: u32 = 2;
pub const SQLITE_INDEX_SCAN_UNIQUE: u32 = 1;
pub const SQLITE_INDEX_CONSTRAINT_EQ: u32 = 2;
pub const SQLITE_INDEX_CONSTRAINT_GT: u32 = 4;
pub const SQLITE_INDEX_CONSTRAINT_LE: u32 = 8;
pub const SQLITE_INDEX_CONSTRAINT_LT: u32 = 16;
pub const SQLITE_INDEX_CONSTRAINT_GE: u32 = 32;
pub const SQLITE_INDEX_CONSTRAINT_MATCH: u32 = 64;
pub const SQLITE_INDEX_CONSTRAINT_LIKE: u32 = 65;
pub const SQLITE_INDEX_CONSTRAINT_GLOB: u32 = 66;
pub const SQLITE_INDEX_CONSTRAINT_REGEXP: u32 = 67;
pub const SQLITE_INDEX_CONSTRAINT_NE: u32 = 68;
pub const SQLITE_INDEX_CONSTRAINT_ISNOT: u32 = 69;
pub const SQLITE_INDEX_CONSTRAINT_ISNOTNULL: u32 = 70;
pub const SQLITE_INDEX_CONSTRAINT_ISNULL: u32 = 71;
pub const SQLITE_INDEX_CONSTRAINT_IS: u32 = 72;
pub const SQLITE_INDEX_CONSTRAINT_LIMIT: u32 = 73;
pub const SQLITE_INDEX_CONSTRAINT_OFFSET: u32 = 74;
pub const SQLITE_INDEX_CONSTRAINT_FUNCTION: u32 = 150;
pub const SQLITE_MUTEX_FAST: u32 = 0;
pub const SQLITE_MUTEX_RECURSIVE: u32 = 1;
pub const SQLITE_MUTEX_STATIC_MAIN: u32 = 2;
pub const SQLITE_MUTEX_STATIC_MEM: u32 = 3;
pub const SQLITE_MUTEX_STATIC_MEM2: u32 = 4;
pub const SQLITE_MUTEX_STATIC_OPEN: u32 = 4;
pub const SQLITE_MUTEX_STATIC_PRNG: u32 = 5;
pub const SQLITE_MUTEX_STATIC_LRU: u32 = 6;
pub const SQLITE_MUTEX_STATIC_LRU2: u32 = 7;
pub const SQLITE_MUTEX_STATIC_PMEM: u32 = 7;
pub const SQLITE_MUTEX_STATIC_APP1: u32 = 8;
pub const SQLITE_MUTEX_STATIC_APP2: u32 = 9;
pub const SQLITE_MUTEX_STATIC_APP3: u32 = 10;
pub const SQLITE_MUTEX_STATIC_VFS1: u32 = 11;
pub const SQLITE_MUTEX_STATIC_VFS2: u32 = 12;
pub const SQLITE_MUTEX_STATIC_VFS3: u32 = 13;
pub const SQLITE_MUTEX_STATIC_MASTER: u32 = 2;
pub const SQLITE_TESTCTRL_FIRST: u32 = 5;
pub const SQLITE_TESTCTRL_PRNG_SAVE: u32 = 5;
pub const SQLITE_TESTCTRL_PRNG_RESTORE: u32 = 6;
pub const SQLITE_TESTCTRL_PRNG_RESET: u32 = 7;
pub const SQLITE_TESTCTRL_BITVEC_TEST: u32 = 8;
pub const SQLITE_TESTCTRL_FAULT_INSTALL: u32 = 9;
pub const SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: u32 = 10;
pub const SQLITE_TESTCTRL_PENDING_BYTE: u32 = 11;
pub const SQLITE_TESTCTRL_ASSERT: u32 = 12;
pub const SQLITE_TESTCTRL_ALWAYS: u32 = 13;
pub const SQLITE_TESTCTRL_RESERVE: u32 = 14;
pub const SQLITE_TESTCTRL_OPTIMIZATIONS: u32 = 15;
pub const SQLITE_TESTCTRL_ISKEYWORD: u32 = 16;
pub const SQLITE_TESTCTRL_SCRATCHMALLOC: u32 = 17;
pub const SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: u32 = 17;
pub const SQLITE_TESTCTRL_LOCALTIME_FAULT: u32 = 18;
pub const SQLITE_TESTCTRL_EXPLAIN_STMT: u32 = 19;
pub const SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: u32 = 19;
pub const SQLITE_TESTCTRL_NEVER_CORRUPT: u32 = 20;
pub const SQLITE_TESTCTRL_VDBE_COVERAGE: u32 = 21;
pub const SQLITE_TESTCTRL_BYTEORDER: u32 = 22;
pub const SQLITE_TESTCTRL_ISINIT: u32 = 23;
pub const SQLITE_TESTCTRL_SORTER_MMAP: u32 = 24;
pub const SQLITE_TESTCTRL_IMPOSTER: u32 = 25;
pub const SQLITE_TESTCTRL_PARSER_COVERAGE: u32 = 26;
pub const SQLITE_TESTCTRL_RESULT_INTREAL: u32 = 27;
pub const SQLITE_TESTCTRL_PRNG_SEED: u32 = 28;
pub const SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: u32 = 29;
pub const SQLITE_TESTCTRL_SEEK_COUNT: u32 = 30;
pub const SQLITE_TESTCTRL_TRACEFLAGS: u32 = 31;
pub const SQLITE_TESTCTRL_TUNE: u32 = 32;
pub const SQLITE_TESTCTRL_LOGEST: u32 = 33;
pub const SQLITE_TESTCTRL_LAST: u32 = 33;
pub const SQLITE_STATUS_MEMORY_USED: u32 = 0;
pub const SQLITE_STATUS_PAGECACHE_USED: u32 = 1;
pub const SQLITE_STATUS_PAGECACHE_OVERFLOW: u32 = 2;
pub const SQLITE_STATUS_SCRATCH_USED: u32 = 3;
pub const SQLITE_STATUS_SCRATCH_OVERFLOW: u32 = 4;
pub const SQLITE_STATUS_MALLOC_SIZE: u32 = 5;
pub const SQLITE_STATUS_PARSER_STACK: u32 = 6;
pub const SQLITE_STATUS_PAGECACHE_SIZE: u32 = 7;
pub const SQLITE_STATUS_SCRATCH_SIZE: u32 = 8;
pub const SQLITE_STATUS_MALLOC_COUNT: u32 = 9;
pub const SQLITE_DBSTATUS_LOOKASIDE_USED: u32 = 0;
pub const SQLITE_DBSTATUS_CACHE_USED: u32 = 1;
pub const SQLITE_DBSTATUS_SCHEMA_USED: u32 = 2;
pub const SQLITE_DBSTATUS_STMT_USED: u32 = 3;
pub const SQLITE_DBSTATUS_LOOKASIDE_HIT: u32 = 4;
pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: u32 = 5;
pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: u32 = 6;
pub const SQLITE_DBSTATUS_CACHE_HIT: u32 = 7;
pub const SQLITE_DBSTATUS_CACHE_MISS: u32 = 8;
pub const SQLITE_DBSTATUS_CACHE_WRITE: u32 = 9;
pub const SQLITE_DBSTATUS_DEFERRED_FKS: u32 = 10;
pub const SQLITE_DBSTATUS_CACHE_USED_SHARED: u32 = 11;
pub const SQLITE_DBSTATUS_CACHE_SPILL: u32 = 12;
pub const SQLITE_DBSTATUS_MAX: u32 = 12;
pub const SQLITE_STMTSTATUS_FULLSCAN_STEP: u32 = 1;
pub const SQLITE_STMTSTATUS_SORT: u32 = 2;
pub const SQLITE_STMTSTATUS_AUTOINDEX: u32 = 3;
pub const SQLITE_STMTSTATUS_VM_STEP: u32 = 4;
pub const SQLITE_STMTSTATUS_REPREPARE: u32 = 5;
pub const SQLITE_STMTSTATUS_RUN: u32 = 6;
pub const SQLITE_STMTSTATUS_FILTER_MISS: u32 = 7;
pub const SQLITE_STMTSTATUS_FILTER_HIT: u32 = 8;
pub const SQLITE_STMTSTATUS_MEMUSED: u32 = 99;
pub const SQLITE_CHECKPOINT_PASSIVE: u32 = 0;
pub const SQLITE_CHECKPOINT_FULL: u32 = 1;
pub const SQLITE_CHECKPOINT_RESTART: u32 = 2;
pub const SQLITE_CHECKPOINT_TRUNCATE: u32 = 3;
pub const SQLITE_VTAB_CONSTRAINT_SUPPORT: u32 = 1;
pub const SQLITE_VTAB_INNOCUOUS: u32 = 2;
pub const SQLITE_VTAB_DIRECTONLY: u32 = 3;
pub const SQLITE_ROLLBACK: u32 = 1;
pub const SQLITE_FAIL: u32 = 3;
pub const SQLITE_REPLACE: u32 = 5;
pub const SQLITE_SCANSTAT_NLOOP: u32 = 0;
pub const SQLITE_SCANSTAT_NVISIT: u32 = 1;
pub const SQLITE_SCANSTAT_EST: u32 = 2;
pub const SQLITE_SCANSTAT_NAME: u32 = 3;
pub const SQLITE_SCANSTAT_EXPLAIN: u32 = 4;
pub const SQLITE_SCANSTAT_SELECTID: u32 = 5;
pub const SQLITE_SERIALIZE_NOCOPY: u32 = 1;
pub const SQLITE_DESERIALIZE_FREEONCLOSE: u32 = 1;
pub const SQLITE_DESERIALIZE_RESIZEABLE: u32 = 2;
pub const SQLITE_DESERIALIZE_READONLY: u32 = 4;
pub const NOT_WITHIN: u32 = 0;
pub const PARTLY_WITHIN: u32 = 1;
pub const FULLY_WITHIN: u32 = 2;
pub const FTS5_TOKENIZE_QUERY: u32 = 1;
pub const FTS5_TOKENIZE_PREFIX: u32 = 2;
pub const FTS5_TOKENIZE_DOCUMENT: u32 = 4;
pub const FTS5_TOKENIZE_AUX: u32 = 8;
pub const FTS5_TOKEN_COLOCATED: u32 = 1;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type size_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = u32;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
pub type bstring = *mut tagbstring;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagbstring {
    pub mlen: ::std::os::raw::c_int,
    pub slen: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_tagbstring() {
    assert_eq!(
        ::std::mem::size_of::<tagbstring>(),
        16usize,
        concat!("Size of: ", stringify!(tagbstring))
    );
    assert_eq!(
        ::std::mem::align_of::<tagbstring>(),
        8usize,
        concat!("Alignment of ", stringify!(tagbstring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagbstring>())).mlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagbstring),
            "::",
            stringify!(mlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagbstring>())).slen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagbstring),
            "::",
            stringify!(slen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagbstring>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagbstring),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Take a standard C library style '\\0' terminated char buffer and generate"]
    #[doc = " a bstring with the same contents as the char buffer."]
    #[doc = ""]
    #[doc = " If an error occurs #NULL is returned."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " bstring b = bfromcstr(\"Hello\");"]
    #[doc = " if(!b) {"]
    #[doc = "     fprintf(stderr, \"Out of memory\");"]
    #[doc = " } else {"]
    #[doc = "     puts((char *)b->data);"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    pub fn bfromcstr(str: *const ::std::os::raw::c_char) -> bstring;
}
extern "C" {
    #[doc = " Create a bstring which contains the contents of the '\\0' terminated"]
    #[doc = " char *buffer str."]
    #[doc = ""]
    #[doc = " The memory buffer backing the bstring is at least mlen characters in"]
    #[doc = " length. If an error occurs NULL is returned."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " bstring b = bfromcstralloc(64, someCstr);"]
    #[doc = " if(b) {"]
    #[doc = "     b->data[63] = 'x';"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " The idea is that this will set the 64th character of b to 'x' if it is at"]
    #[doc = " least 64 characters long otherwise do nothing. And we know this is well"]
    #[doc = " defined so long as b was successfully created, since it will have been"]
    #[doc = " allocated with at least 64 characters."]
    pub fn bfromcstralloc(
        mlen: ::std::os::raw::c_int,
        str: *const ::std::os::raw::c_char,
    ) -> bstring;
}
extern "C" {
    #[doc = " Create a bstring whose contents are described by the contiguous buffer"]
    #[doc = " pointing to by blk with a length of len bytes."]
    #[doc = ""]
    #[doc = " Note that this function creates a copy of the data in blk, rather than"]
    #[doc = " simply referencing it. Compare with the blk2tbstr macro. If an error"]
    #[doc = " occurs NULL is returned."]
    pub fn blk2bstr(blk: *const ::std::os::raw::c_void, len: ::std::os::raw::c_int) -> bstring;
}
extern "C" {
    #[doc = " Create a '\\0' terminated char buffer which contains the contents of the"]
    #[doc = " bstring s, except that any contained '\\0' characters are converted to the"]
    #[doc = " character in z."]
    #[doc = ""]
    #[doc = " This returned value should be freed with bcstrfree(), by the caller. If"]
    #[doc = " an error occurs NULL is returned."]
    pub fn bstr2cstr(s: bstring, z: ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees a C-string generated by bstr2cstr()."]
    #[doc = ""]
    #[doc = " This is normally unnecessary since it just wraps a call to free(),"]
    #[doc = " however, if malloc() and free() have been redefined as a macros within"]
    #[doc = " the bstrlib module (via macros in the memdbg.h backdoor) with some"]
    #[doc = " difference in behaviour from the std library functions, then this allows"]
    #[doc = " a correct way of freeing the memory that allows higher level code to be"]
    #[doc = " independent from these macro redefinitions."]
    pub fn bcstrfree(s: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make a copy of the passed in bstring."]
    #[doc = ""]
    #[doc = " The copied bstring is returned if there is no error, otherwise NULL is"]
    #[doc = " returned."]
    pub fn bstrcpy(b1: bstring) -> bstring;
}
extern "C" {
    #[doc = " Overwrite the bstring a with the contents of bstring b."]
    #[doc = ""]
    #[doc = " Note that the bstring a must be a well defined and writable bstring. If"]
    #[doc = " an error occurs BSTR_ERR is returned and a is not overwritten."]
    pub fn bassign(a: bstring, b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overwrite the bstring a with the middle of contents of bstring b"]
    #[doc = " starting from position left and running for a length len."]
    #[doc = ""]
    #[doc = " left and len are clamped to the ends of b as with the function bmidstr."]
    #[doc = " Note that the bstring a must be a well defined and writable bstring. If"]
    #[doc = " an error occurs BSTR_ERR is returned and a is not overwritten."]
    pub fn bassignmidstr(
        a: bstring,
        b: bstring,
        left: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overwrite the string a with the contents of char * string str."]
    #[doc = ""]
    #[doc = " Note that the bstring a must be a well defined and writable bstring. If"]
    #[doc = " an error occurs BSTR_ERR is returned and a may be partially overwritten."]
    pub fn bassigncstr(a: bstring, str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overwrite the bstring a with the middle of contents of bstring b"]
    #[doc = " starting from position left and running for a length len."]
    #[doc = ""]
    #[doc = " left and len are clamped to the ends of b as with the function bmidstr."]
    #[doc = " Note that the bstring a must be a well defined and writable bstring. If"]
    #[doc = " an error occurs BSTR_ERR is returned and a is not overwritten."]
    pub fn bassignblk(
        a: bstring,
        s: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocate the bstring passed."]
    #[doc = ""]
    #[doc = " Passing NULL in as a parameter will have no effect. Note that both the"]
    #[doc = " header and the data portion of the bstring will be freed. No other"]
    #[doc = " bstring function which modifies one of its parameters will free or"]
    #[doc = " reallocate the header. Because of this, in general, bdestroy cannot be"]
    #[doc = " called on any declared struct tagbstring even if it is not write"]
    #[doc = " protected. A bstring which is write protected cannot be destroyed via the"]
    #[doc = " bdestroy call. Any attempt to do so will result in no action taken, and"]
    #[doc = " BSTR_ERR will be returned."]
    pub fn bdestroy(b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Increase the allocated memory backing the data buffer for the bstring b"]
    #[doc = " to a length of at least length."]
    #[doc = ""]
    #[doc = " If the memory backing the bstring b is already large enough, not action is"]
    #[doc = " performed. This has no effect on the bstring b that is visible to the"]
    #[doc = " bstring API. Usually this function will only be used when a minimum buffer"]
    #[doc = " size is required coupled with a direct access to the ->data member of the"]
    #[doc = " bstring structure."]
    #[doc = ""]
    #[doc = " Be warned that like any other bstring function, the bstring must be well"]
    #[doc = " defined upon entry to this function, i.e., doing something like:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " b->slen *= 2;"]
    #[doc = " balloc(b, b->slen);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " is invalid, and should be implemented as:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " int t;"]
    #[doc = " if (BSTR_OK == balloc (b, t = (b->slen * 2))) {"]
    #[doc = "     b->slen = t;"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " This function will return with BSTR_ERR if b is not detected as a valid"]
    #[doc = " bstring or length is not greater than 0, otherwise BSTR_OK is returned."]
    pub fn balloc(s: bstring, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the amount of memory backing the bstring b to at least length."]
    #[doc = ""]
    #[doc = " This operation will never truncate the bstring data including the"]
    #[doc = " extra terminating '\\0' and thus will not decrease the length to less than"]
    #[doc = " b->slen + 1. Note that repeated use of this function may cause"]
    #[doc = " performance problems (realloc may be called on the bstring more than"]
    #[doc = " the O(log(INT_MAX)) times). This function will return with BSTR_ERR if b"]
    #[doc = " is not detected as a valid bstring or length is not greater than 0,"]
    #[doc = " otherwise BSTR_OK is returned."]
    #[doc = ""]
    #[doc = " So for example:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " if (BSTR_OK == ballocmin (b, 64)) {"]
    #[doc = "     b->data[63] = 'x';"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " The idea is that this will set the 64th character of b to 'x' if it is at"]
    #[doc = " least 64 characters long otherwise do nothing. And we know this is well"]
    #[doc = " defined so long as the ballocmin call was successfully, since it will"]
    #[doc = " ensure that b has been allocated with at least 64 characters."]
    pub fn ballocmin(b: bstring, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a bstring which is the substring of b starting from position left"]
    #[doc = " and running for a length len (clamped by the end of the bstring b)."]
    #[doc = ""]
    #[doc = " If there was no error, the value of this constructed bstring is returned"]
    #[doc = " otherwise NULL is returned."]
    pub fn bmidstr(b: bstring, left: ::std::os::raw::c_int, len: ::std::os::raw::c_int) -> bstring;
}
extern "C" {
    #[doc = " Concatenate the bstring b1 to the end of bstring b0."]
    #[doc = ""]
    #[doc = " The value BSTR_OK is returned if the operation is successful, otherwise"]
    #[doc = " BSTR_ERR is returned."]
    pub fn bconcat(b0: bstring, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Concatenate the character c to the end of bstring b."]
    #[doc = ""]
    #[doc = " The value BSTR_OK is returned if the operation is successful, otherwise"]
    #[doc = " BSTR_ERR is returned."]
    pub fn bconchar(b0: bstring, c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Concatenate the char * string s to the end of bstring b."]
    #[doc = ""]
    #[doc = " The value BSTR_OK is returned if the operation is successful, otherwise"]
    #[doc = " BSTR_ERR is returned."]
    pub fn bcatcstr(b: bstring, s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Concatenate a fixed length buffer (s, len) to the end of bstring b."]
    #[doc = ""]
    #[doc = " The value BSTR_OK is returned if the operation is successful, otherwise"]
    #[doc = " BSTR_ERR is returned."]
    pub fn bcatblk(
        b: bstring,
        s: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inserts the bstring s2 into s1 at position pos."]
    #[doc = ""]
    #[doc = " If the position pos is past the end of s1, then the character \"fill\" is"]
    #[doc = " appended as necessary to make up the gap between the end of s1 and pos. The"]
    #[doc = " value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR"]
    #[doc = " is returned."]
    pub fn binsert(
        s1: bstring,
        pos: ::std::os::raw::c_int,
        s2: bstring,
        fill: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inserts the character fill repeatedly into s1 at position pos for a"]
    #[doc = " length len."]
    #[doc = ""]
    #[doc = " If the position pos is past the end of s1, then the character \"fill\" is"]
    #[doc = " appended as necessary to make up the gap between the end of s1 and the"]
    #[doc = " position pos + len (exclusive). The value BSTR_OK is returned if the"]
    #[doc = " operation is successful, otherwise BSTR_ERR is returned."]
    pub fn binsertch(
        s1: bstring,
        pos: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        fill: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replace a section of a bstring from pos for a length len with the bstring"]
    #[doc = " b2."]
    #[doc = ""]
    #[doc = " If the position pos is past the end of b1 then the character \"fill\" is"]
    #[doc = " appended as necessary to make up the gap between the end of b1 and pos."]
    pub fn breplace(
        b1: bstring,
        pos: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        b2: bstring,
        fill: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes characters from pos to pos+len-1 and shifts the tail of the"]
    #[doc = " bstring starting from pos+len to pos."]
    #[doc = ""]
    #[doc = " len must be positive for this call to have any effect. The section of the"]
    #[doc = " bstring described by (pos, len) is clamped to boundaries of the bstring b."]
    #[doc = " The value BSTR_OK is returned if the operation is successful, otherwise"]
    #[doc = " BSTR_ERR is returned."]
    pub fn bdelete(
        s1: bstring,
        pos: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overwrite the bstring b0 starting at position pos with the bstring b1."]
    #[doc = ""]
    #[doc = " If the position pos is past the end of b0, then the character \"fill\" is"]
    #[doc = " appended as necessary to make up the gap between the end of b0 and pos.  If"]
    #[doc = " b1 is NULL, it behaves as if it were a 0-length bstring. The value BSTR_OK"]
    #[doc = " is returned if the operation is successful, otherwise BSTR_ERR is returned."]
    pub fn bsetstr(
        b0: bstring,
        pos: ::std::os::raw::c_int,
        b1: bstring,
        fill: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Truncate the bstring to at most n characters."]
    #[doc = ""]
    #[doc = " This function will return with BSTR_ERR if b is not detected as a valid"]
    #[doc = " bstring or n is less than 0, otherwise BSTR_OK is returned."]
    pub fn btrunc(b: bstring, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two bstrings without differentiating between case."]
    #[doc = ""]
    #[doc = " The return value is the difference of the values of the characters where the"]
    #[doc = " two bstrings first differ, otherwise 0 is returned indicating that the"]
    #[doc = " bstrings are equal. If the lengths are different, then a difference from 0"]
    #[doc = " is given, but if the first extra character is '\\0', then it is taken to be"]
    #[doc = " the value UCHAR_MAX + 1."]
    pub fn bstricmp(b0: bstring, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two bstrings without differentiating between case for at most n"]
    #[doc = " characters."]
    #[doc = ""]
    #[doc = " If the position where the two bstrings first differ is before the nth"]
    #[doc = " position, the return value is the difference of the values of the"]
    #[doc = " characters, otherwise 0 is returned. If the lengths are different and less"]
    #[doc = " than n characters, then a difference from 0 is given, but if the first extra"]
    #[doc = " character is '\\0', then it is taken to be the value UCHAR_MAX + 1."]
    pub fn bstrnicmp(b0: bstring, b1: bstring, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two bstrings for equality without differentiating between case."]
    #[doc = ""]
    #[doc = " If the bstrings differ other than in case, 0 is returned, if the bstrings"]
    #[doc = " are the same, 1 is returned, if there is an error, -1 is returned. If"]
    #[doc = " the length of the bstrings are different, this function is O(1). '\\0'"]
    #[doc = " termination characters are not treated in any special way."]
    pub fn biseqcaseless(b0: bstring, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare beginning of bstring b0 with a block of memory of length len"]
    #[doc = " without differentiating between case for equality."]
    #[doc = ""]
    #[doc = " If the beginning of b0 differs from the memory block other than in case (or"]
    #[doc = " if b0 is too short), 0 is returned, if the bstrings are the same, 1 is"]
    #[doc = " returned, if there is an error, -1 is returned."]
    pub fn bisstemeqcaselessblk(
        b0: bstring,
        blk: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the bstring b0 and b1 for equality."]
    #[doc = ""]
    #[doc = " If the bstrings differ, 0 is returned, if the bstrings are the same, 1 is"]
    #[doc = " returned, if there is an error, -1 is returned. If the length of the"]
    #[doc = " bstrings are different, this function has O(1) complexity. Contained '\\0'"]
    #[doc = " characters are not treated as a termination character."]
    #[doc = ""]
    #[doc = " Note that the semantics of biseq are not completely compatible with"]
    #[doc = " bstrcmp because of its different treatment of the '\\0' character."]
    pub fn biseq(b0: bstring, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare beginning of bstring b0 with a block of memory of length len for"]
    #[doc = " equality."]
    #[doc = ""]
    #[doc = " If the beginning of b0 differs from the memory block (or if b0 is too"]
    #[doc = " short), 0 is returned, if the bstrings are the same, 1 is returned, if there"]
    #[doc = " is an error, -1 is returned."]
    pub fn bisstemeqblk(
        b0: bstring,
        blk: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the bstring b and char * string s."]
    #[doc = ""]
    #[doc = " The C string s must be '\\0' terminated at exactly the length of the bstring"]
    #[doc = " b, and the contents between the two must be identical with the bstring b"]
    #[doc = " with no '\\0' characters for the two contents to be considered equal. This is"]
    #[doc = " equivalent to the condition that their current contents will be always be"]
    #[doc = " equal when comparing them in the same format after converting one or the"]
    #[doc = " other. If they are equal 1 is returned, if they are unequal 0 is returned"]
    #[doc = " and if there is a detectable error BSTR_ERR is returned."]
    pub fn biseqcstr(b: bstring, s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the bstring b and char * string s."]
    #[doc = ""]
    #[doc = " The C string s must be '\\0' terminated at exactly the length of the bstring"]
    #[doc = " b, and the contents between the two must be identical except for case with"]
    #[doc = " the bstring b with no '\\0' characters for the two contents to be considered"]
    #[doc = " equal. This is equivalent to the condition that their current contents will"]
    #[doc = " be always be equal ignoring case when comparing them in the same format"]
    #[doc = " after converting one or the other. If they are equal, except for case, 1 is"]
    #[doc = " returned, if they are unequal regardless of case 0 is returned and if there"]
    #[doc = " is a detectable error BSTR_ERR is returned."]
    pub fn biseqcstrcaseless(b: bstring, s: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the bstrings b0 and b1 for ordering."]
    #[doc = ""]
    #[doc = " If there is an error, SHRT_MIN is returned, otherwise a value less than or"]
    #[doc = " greater than zero, indicating that the bstring pointed to by b0 is"]
    #[doc = " lexicographically less than or greater than the bstring pointed to by b1 is"]
    #[doc = " returned. If the bstring lengths are unequal but the characters up until the"]
    #[doc = " length of the shorter are equal then a value less than, or greater than"]
    #[doc = " zero, indicating that the bstring pointed to by b0 is shorter or longer than"]
    #[doc = " the bstring pointed to by b1 is returned. 0 is returned if and only if the"]
    #[doc = " two bstrings are the same. If the length of the bstrings are different, this"]
    #[doc = " function is O(n). Like its standard C library counter part, the comparison"]
    #[doc = " does not proceed past any '\\0' termination characters encountered."]
    #[doc = ""]
    #[doc = " The seemingly odd error return value, merely provides slightly more"]
    #[doc = " granularity than the undefined situation given in the C library function"]
    #[doc = " strcmp. The function otherwise behaves very much like strcmp()."]
    #[doc = ""]
    #[doc = " Note that the semantics of bstrcmp are not completely compatible with"]
    #[doc = " biseq because of its different treatment of the '\\0' termination"]
    #[doc = " character."]
    pub fn bstrcmp(b0: bstring, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the bstrings b0 and b1 for ordering for at most n characters."]
    #[doc = ""]
    #[doc = " If there is an error, SHRT_MIN is returned, otherwise a value is returned as"]
    #[doc = " if b0 and b1 were first truncated to at most n characters then bstrcmp was"]
    #[doc = " called with these new bstrings are paremeters. If the length of the bstrings"]
    #[doc = " are different, this function is O(n). Like its standard C library counter"]
    #[doc = " part, the comparison does not proceed past any '\\0' termination characters"]
    #[doc = " encountered."]
    #[doc = ""]
    #[doc = " The seemingly odd error return value, merely provides slightly more"]
    #[doc = " granularity than the undefined situation given in the C library function"]
    #[doc = " strncmp. The function otherwise behaves very much like strncmp()."]
    pub fn bstrncmp(b0: bstring, b1: bstring, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the bstring s2 in s1 starting at position pos and looking in a"]
    #[doc = " forward (increasing) direction."]
    #[doc = ""]
    #[doc = " If it is found then it returns with the first position after pos where it is"]
    #[doc = " found, otherwise it returns BSTR_ERR.  The algorithm used is brute force;"]
    #[doc = " O(m*n)."]
    pub fn binstr(s1: bstring, pos: ::std::os::raw::c_int, s2: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the bstring s2 in s1 starting at position pos and looking in a"]
    #[doc = " backward (decreasing) direction."]
    #[doc = ""]
    #[doc = " If it is found then it returns with the first position after pos where it is"]
    #[doc = " found, otherwise return BSTR_ERR.  Note that the current position at pos is"]
    #[doc = " tested as well -- so to be disjoint from a previous forward search it is"]
    #[doc = " recommended that the position be backed up (decremented) by one position."]
    #[doc = " The algorithm used is brute force; O(m*n)."]
    pub fn binstrr(s1: bstring, pos: ::std::os::raw::c_int, s2: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the bstring s2 in s1 starting at position pos and looking in a"]
    #[doc = " forward (increasing) direction but without regard to case."]
    #[doc = ""]
    #[doc = " If it is found then it returns with the first position after pos where it is"]
    #[doc = " found, otherwise it returns BSTR_ERR. The algorithm used is brute force;"]
    #[doc = " O(m*n)."]
    pub fn binstrcaseless(
        s1: bstring,
        pos: ::std::os::raw::c_int,
        s2: bstring,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the bstring s2 in s1 starting at position pos and looking in a"]
    #[doc = " backward (decreasing) direction but without regard to case."]
    #[doc = ""]
    #[doc = " If it is found then it returns with the first position after pos where it is"]
    #[doc = " found, otherwise return BSTR_ERR. Note that the current position at pos is"]
    #[doc = " tested as well -- so to be disjoint from a previous forward search it is"]
    #[doc = " recommended that the position be backed up (decremented) by one position."]
    #[doc = " The algorithm used is brute force; O(m*n)."]
    pub fn binstrrcaseless(
        s1: bstring,
        pos: ::std::os::raw::c_int,
        s2: bstring,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the character c in b forwards from the position pos"]
    #[doc = " (inclusive)."]
    #[doc = ""]
    #[doc = " Returns the position of the found character or BSTR_ERR if it is not found."]
    pub fn bstrchrp(
        b: bstring,
        c: ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the character c in b backwards from the position pos in bstring"]
    #[doc = " (inclusive)."]
    #[doc = ""]
    #[doc = " Returns the position of the found character or BSTR_ERR if it is not found."]
    pub fn bstrrchrp(
        b: bstring,
        c: ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the first position in b0 starting from pos or after, in which"]
    #[doc = " one of the characters in b1 is found."]
    #[doc = ""]
    #[doc = " This function has an execution time of O(b0->slen + b1->slen). If such a"]
    #[doc = " position does not exist in b0, then BSTR_ERR is returned."]
    pub fn binchr(b0: bstring, pos: ::std::os::raw::c_int, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the last position in b0 no greater than pos, in which one of"]
    #[doc = " the characters in b1 is found."]
    #[doc = ""]
    #[doc = " This function has an execution time of O(b0->slen + b1->slen). If such a"]
    #[doc = " position does not exist in b0, then BSTR_ERR is returned."]
    pub fn binchrr(b0: bstring, pos: ::std::os::raw::c_int, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the first position in b0 starting from pos or after, in which"]
    #[doc = " none of the characters in b1 is found and return it."]
    #[doc = ""]
    #[doc = " This function has an execution time of O(b0->slen + b1->slen). If such a"]
    #[doc = " position does not exist in b0, then BSTR_ERR is returned."]
    pub fn bninchr(b0: bstring, pos: ::std::os::raw::c_int, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for the last position in b0 no greater than pos, in which none of"]
    #[doc = " the characters in b1 is found and return it."]
    #[doc = ""]
    #[doc = " This function has an execution time of O(b0->slen + b1->slen). If such a"]
    #[doc = " position does not exist in b0, then BSTR_ERR is returned."]
    pub fn bninchrr(b0: bstring, pos: ::std::os::raw::c_int, b1: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replace all occurrences of the find substring with a replace bstring"]
    #[doc = " after a given position in the bstring b."]
    #[doc = ""]
    #[doc = " The find bstring must have a length > 0 otherwise BSTR_ERR is returned. This"]
    #[doc = " function does not perform recursive per character replacement; that is to"]
    #[doc = " say successive searches resume at the position after the last replace."]
    #[doc = ""]
    #[doc = " So for example:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " bfindreplace(a0 = bfromcstr(\"aabaAb\"), a1 = bfromcstr(\"a\"),"]
    #[doc = "              a2 = bfromcstr(\"aa\"), 0);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " Should result in changing a0 to \"aaaabaaAb\"."]
    #[doc = ""]
    #[doc = " This function performs exactly (b->slen - position) bstring comparisons,"]
    #[doc = " and data movement is bounded above by character volume equivalent to size"]
    #[doc = " of the output bstring."]
    pub fn bfindreplace(
        b: bstring,
        find: bstring,
        repl: bstring,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replace all occurrences of the find substring, ignoring case, with a"]
    #[doc = " replace bstring after a given position in the bstring b."]
    #[doc = ""]
    #[doc = " The find bstring must have a length > 0 otherwise BSTR_ERR is returned. This"]
    #[doc = " function does not perform recursive per character replacement; that is to"]
    #[doc = " say successive searches resume at the position after the last replace."]
    #[doc = ""]
    #[doc = " So for example:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " bfindreplacecaseless(a0 = bfromcstr(\"AAbaAb\"), a1 = bfromcstr(\"a\"),"]
    #[doc = " a2 = bfromcstr(\"aa\"), 0);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " Should result in changing a0 to \"aaaabaaaab\"."]
    #[doc = ""]
    #[doc = " This function performs exactly (b->slen - position) bstring comparisons,"]
    #[doc = " and data movement is bounded above by character volume equivalent to size"]
    #[doc = " of the output bstring."]
    pub fn bfindreplacecaseless(
        b: bstring,
        find: bstring,
        repl: bstring,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bstrList {
    pub qty: ::std::os::raw::c_int,
    pub mlen: ::std::os::raw::c_int,
    pub entry: *mut bstring,
}
#[test]
fn bindgen_test_layout_bstrList() {
    assert_eq!(
        ::std::mem::size_of::<bstrList>(),
        16usize,
        concat!("Size of: ", stringify!(bstrList))
    );
    assert_eq!(
        ::std::mem::align_of::<bstrList>(),
        8usize,
        concat!("Alignment of ", stringify!(bstrList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bstrList>())).qty as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bstrList),
            "::",
            stringify!(qty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bstrList>())).mlen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bstrList),
            "::",
            stringify!(mlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bstrList>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bstrList),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    #[doc = " Create an empty struct bstrList."]
    #[doc = ""]
    #[doc = " The struct bstrList output structure is declared as follows:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " struct bstrList {"]
    #[doc = "     int qty, mlen;"]
    #[doc = "     bstring *entry;"]
    #[doc = " };"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " The entry field actually is an array with qty number entries. The mlen"]
    #[doc = " record counts the maximum number of bstring's for which there is memory"]
    #[doc = " in the entry record."]
    #[doc = ""]
    #[doc = " The Bstrlib API does *NOT* include a comprehensive set of functions for"]
    #[doc = " full management of struct bstrList in an abstracted way. The reason for"]
    #[doc = " this is because aliasing semantics of the list are best left to the user"]
    #[doc = " of this function, and performance varies wildly depending on the"]
    #[doc = " assumptions made."]
    pub fn bstrListCreate() -> *mut bstrList;
}
extern "C" {
    #[doc = " Destroy a struct bstrList structure that was returned by the bsplit"]
    #[doc = " function. Note that this will destroy each bstring in the ->entry array"]
    #[doc = " as well. See bstrListCreate() above for structure of struct bstrList."]
    pub fn bstrListDestroy(sl: *mut bstrList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure that there is memory for at least msz number of entries for the"]
    #[doc = " list."]
    pub fn bstrListAlloc(sl: *mut bstrList, msz: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to allocate the minimum amount of memory for the list to include at"]
    #[doc = " least msz entries or sl->qty whichever is greater."]
    pub fn bstrListAllocMin(sl: *mut bstrList, msz: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create an array of sequential substrings from str divided by the"]
    #[doc = " character splitChar."]
    #[doc = ""]
    #[doc = " Successive occurrences of the splitChar will be divided by empty bstring"]
    #[doc = " entries, following the semantics from the Python programming language. To"]
    #[doc = " reclaim the memory from this output structure, bstrListDestroy() should be"]
    #[doc = " called. See bstrListCreate() above for structure of struct bstrList."]
    pub fn bsplit(str: bstring, splitChar: ::std::os::raw::c_uchar) -> *mut bstrList;
}
extern "C" {
    #[doc = " Create an array of sequential substrings from str divided by any"]
    #[doc = " character contained in splitStr."]
    #[doc = ""]
    #[doc = " An empty splitStr causes a single entry bstrList containing a copy of str to"]
    #[doc = " be returned. See bstrListCreate() above for structure of struct bstrList."]
    pub fn bsplits(str: bstring, splitStr: bstring) -> *mut bstrList;
}
extern "C" {
    #[doc = " Create an array of sequential substrings from str divided by the entire"]
    #[doc = " substring splitStr."]
    #[doc = ""]
    #[doc = " An empty splitStr causes a single entry bstrList containing a copy of str to"]
    #[doc = " be returned. See bstrListCreate() above for structure of struct bstrList."]
    pub fn bsplitstr(str: bstring, splitStr: bstring) -> *mut bstrList;
}
extern "C" {
    #[doc = " Join the entries of a bstrList into one bstring by sequentially"]
    #[doc = " concatenating them with the sep bstring in between."]
    #[doc = ""]
    #[doc = " If sep is NULL, it is treated as if it were the empty bstring. Note that:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " bjoin (l = bsplit (b, s->data[0]), s);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " should result in a copy of b, if s->slen is 1. If there is an error NULL"]
    #[doc = " is returned, otherwise a bstring with the correct result is returned."]
    #[doc = " See bstrListCreate() above for structure of struct bstrList."]
    pub fn bjoin(bl: *const bstrList, sep: bstring) -> bstring;
}
extern "C" {
    #[doc = " Iterate the set of disjoint sequential substrings over str starting at"]
    #[doc = " position pos divided by the character splitChar."]
    #[doc = ""]
    #[doc = " The parm passed to bsplitcb is passed on to cb. If the function cb returns a"]
    #[doc = " value < 0, then further iterating is halted and this value is returned by"]
    #[doc = " bsplitcb."]
    #[doc = ""]
    #[doc = " Note: Non-destructive modification of str from within the cb function"]
    #[doc = " while performing this split is not undefined. bsplitcb behaves in"]
    #[doc = " sequential lock step with calls to cb. I.e., after returning from a cb"]
    #[doc = " that return a non-negative integer, bsplitcb continues from the position"]
    #[doc = " 1 character after the last detected split character and it will halt"]
    #[doc = " immediately if the length of str falls below this point. However, if the"]
    #[doc = " cb function destroys str, then it *must* return with a negative value,"]
    #[doc = " otherwise bsplitcb will continue in an undefined manner."]
    #[doc = ""]
    #[doc = " This function is provided as an incremental alternative to bsplit that is"]
    #[doc = " abortable and which does not impose additional memory allocation."]
    pub fn bsplitcb(
        str: bstring,
        splitChar: ::std::os::raw::c_uchar,
        pos: ::std::os::raw::c_int,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                parm: *mut ::std::os::raw::c_void,
                ofs: ::std::os::raw::c_int,
                len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        parm: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate the set of disjoint sequential substrings over str starting at"]
    #[doc = " position pos divided by any of the characters in splitStr."]
    #[doc = ""]
    #[doc = " An empty splitStr causes the whole str to be iterated once. The parm passed"]
    #[doc = " to bsplitcb is passed on to cb. If the function cb returns a value < 0, then"]
    #[doc = " further iterating is halted and this value is returned by bsplitcb."]
    #[doc = ""]
    #[doc = " Note: Non-destructive modification of str from within the cb function"]
    #[doc = " while performing this split is not undefined. bsplitscb behaves in"]
    #[doc = " sequential lock step with calls to cb. I.e., after returning from a cb"]
    #[doc = " that return a non-negative integer, bsplitscb continues from the position"]
    #[doc = " 1 character after the last detected split character and it will halt"]
    #[doc = " immediately if the length of str falls below this point. However, if the"]
    #[doc = " cb function destroys str, then it *must* return with a negative value,"]
    #[doc = " otherwise bsplitscb will continue in an undefined manner."]
    #[doc = ""]
    #[doc = " This function is provided as an incremental alternative to bsplits that"]
    #[doc = " is abortable and which does not impose additional memory allocation."]
    pub fn bsplitscb(
        str: bstring,
        splitStr: bstring,
        pos: ::std::os::raw::c_int,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                parm: *mut ::std::os::raw::c_void,
                ofs: ::std::os::raw::c_int,
                len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        parm: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate the set of disjoint sequential substrings over str starting at"]
    #[doc = " position pos divided by the entire substring splitStr."]
    #[doc = ""]
    #[doc = " An empty splitStr causes each character of str to be iterated. The parm"]
    #[doc = " passed to bsplitcb is passed on to cb. If the function cb returns a value <"]
    #[doc = " 0, then further iterating is halted and this value is returned by bsplitcb."]
    #[doc = ""]
    #[doc = " Note: Non-destructive modification of str from within the cb function"]
    #[doc = " while performing this split is not undefined. bsplitstrcb behaves in"]
    #[doc = " sequential lock step with calls to cb. I.e., after returning from a cb"]
    #[doc = " that return a non-negative integer, bsplitstrcb continues from the position"]
    #[doc = " 1 character after the last detected split character and it will halt"]
    #[doc = " immediately if the length of str falls below this point. However, if the"]
    #[doc = " cb function destroys str, then it *must* return with a negative value,"]
    #[doc = " otherwise bsplitscb will continue in an undefined manner."]
    #[doc = ""]
    #[doc = " This function is provided as an incremental alternative to bsplitstr that"]
    #[doc = " is abortable and which does not impose additional memory allocation."]
    pub fn bsplitstrcb(
        str: bstring,
        splitStr: bstring,
        pos: ::std::os::raw::c_int,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                parm: *mut ::std::os::raw::c_void,
                ofs: ::std::os::raw::c_int,
                len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        parm: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replicate the starting bstring, b, end to end repeatedly until it"]
    #[doc = " surpasses len characters, then chop the result to exactly len characters."]
    #[doc = ""]
    #[doc = " This function operates in-place. This function will return with BSTR_ERR"]
    #[doc = " if b is NULL or of length 0, otherwise BSTR_OK is returned."]
    pub fn bpattern(b: bstring, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert contents of bstring to upper case."]
    #[doc = ""]
    #[doc = " This function will return with BSTR_ERR if b is NULL or of length 0,"]
    #[doc = " otherwise BSTR_OK is returned."]
    pub fn btoupper(b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert contents of bstring to lower case."]
    #[doc = ""]
    #[doc = " This function will return with BSTR_ERR if b is NULL or of length 0,"]
    #[doc = " otherwise BSTR_OK is returned."]
    pub fn btolower(b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete whitespace contiguous from the left end of the bstring."]
    #[doc = ""]
    #[doc = " This function will return with BSTR_ERR if b is NULL or of length 0,"]
    #[doc = " otherwise BSTR_OK is returned."]
    pub fn bltrimws(b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete whitespace contiguous from the right end of the bstring."]
    #[doc = ""]
    #[doc = " This function will return with BSTR_ERR if b is NULL or of length 0,"]
    #[doc = " otherwise BSTR_OK is returned."]
    pub fn brtrimws(b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete whitespace contiguous from both ends of the bstring."]
    #[doc = ""]
    #[doc = " This function will return with BSTR_ERR if b is NULL or of length 0,"]
    #[doc = " otherwise BSTR_OK is returned."]
    pub fn btrimws(b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Takes the same parameters as printf(), but rather than outputting"]
    #[doc = " results to stdio, it forms a bstring which contains what would have been"]
    #[doc = " output."]
    #[doc = ""]
    #[doc = " Note that if there is an early generation of a '\\0' character, the bstring"]
    #[doc = " will be truncated to this end point."]
    #[doc = ""]
    #[doc = " Note that %s format tokens correspond to '\\0' terminated char * buffers,"]
    #[doc = " not bstrings. To print a bstring, first dereference data element of the"]
    #[doc = " the bstring:"]
    #[doc = ""]
    #[doc = " b1->data needs to be '\\0' terminated, so tagbstrings generated by"]
    #[doc = " blk2tbstr() might not be suitable."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " b0 = bformat (\"Hello, %s\", b1->data);"]
    #[doc = " \\endcode"]
    pub fn bformat(fmt: *const ::std::os::raw::c_char, ...) -> bstring;
}
extern "C" {
    #[doc = " In addition to the initial output buffer b, bformata takes the same"]
    #[doc = " parameters as printf (), but rather than outputting results to stdio, it"]
    #[doc = " appends the results to the initial bstring parameter."]
    #[doc = ""]
    #[doc = " Note that if there is an early generation of a '\\0' character, the bstring"]
    #[doc = " will be truncated to this end point."]
    #[doc = ""]
    #[doc = " Note that %s format tokens correspond to '\\0' terminated char * buffers,"]
    #[doc = " not bstrings. To print a bstring, first dereference data element of the"]
    #[doc = " the bstring:"]
    #[doc = ""]
    #[doc = " b1->data needs to be '\\0' terminated, so tagbstrings generated by"]
    #[doc = " blk2tbstr() might not be suitable."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " bformata (b0 = bfromcstr (\"Hello\"), \", %s\", b1->data);"]
    #[doc = " \\endcode"]
    pub fn bformata(b: bstring, fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " After the first parameter, it takes the same parameters as printf(), but"]
    #[doc = " rather than outputting results to stdio, it outputs the results to"]
    #[doc = " the bstring parameter b."]
    #[doc = ""]
    #[doc = " Note that if there is an early generation of a '\\0' character, the bstring"]
    #[doc = " will be truncated to this end point."]
    #[doc = ""]
    #[doc = " Note that %s format tokens correspond to '\\0' terminated char * buffers,"]
    #[doc = " not bstrings. To print a bstring, first dereference data element of the"]
    #[doc = " the bstring:"]
    #[doc = ""]
    #[doc = " b1->data needs to be '\\0' terminated, so tagbstrings generated by"]
    #[doc = " blk2tbstr() might not be suitable."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " bassignformat (b0 = bfromcstr (\"Hello\"), \", %s\", b1->data);"]
    #[doc = " \\endcode"]
    pub fn bassignformat(
        b: bstring,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The bvcformata function formats data under control of the format control"]
    #[doc = " string fmt and attempts to append the result to b."]
    #[doc = ""]
    #[doc = " The fmt parameter is the same as that of the printf function. The variable"]
    #[doc = " argument list is replaced with arglist, which has been initialized by the"]
    #[doc = " va_start macro.  The size of the output is upper bounded by count. If the"]
    #[doc = " required output exceeds count, the string b is not augmented with any"]
    #[doc = " contents and a value below BSTR_ERR is returned. If a value below -count is"]
    #[doc = " returned then it is recommended that the negative of this value be used as"]
    #[doc = " an update to the count in a subsequent pass. On other errors, such as"]
    #[doc = " running out of memory, parameter errors or numeric wrap around BSTR_ERR is"]
    #[doc = " returned.  BSTR_OK is returned when the output is successfully generated and"]
    #[doc = " appended to b."]
    #[doc = ""]
    #[doc = " Note: There is no sanity checking of arglist, and this function is"]
    #[doc = " destructive of the contents of b from the b->slen point onward. If there"]
    #[doc = " is an early generation of a '\\0' character, the bstring will be truncated"]
    #[doc = " to this end point."]
    #[doc = ""]
    #[doc = " Although this function is part of the external API for Bstrlib, the"]
    #[doc = " interface and semantics (length limitations, and unusual return codes)"]
    #[doc = " are fairly atypical. The real purpose for this function is to provide an"]
    #[doc = " engine for the bvformata macro."]
    pub fn bvcformata(
        b: bstring,
        count: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        arglist: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub type bNgetc = ::std::option::Option<
    unsafe extern "C" fn(parm: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type bNread = ::std::option::Option<
    unsafe extern "C" fn(
        buff: *mut ::std::os::raw::c_void,
        elsize: size_t,
        nelem: size_t,
        parm: *mut ::std::os::raw::c_void,
    ) -> size_t,
>;
extern "C" {
    #[doc = " Read a bstring from a stream."]
    #[doc = ""]
    #[doc = " As many bytes as is necessary are read until the terminator is consumed or"]
    #[doc = " no more characters are available from the stream. If read from the stream,"]
    #[doc = " the terminator character will be appended to the end of the returned"]
    #[doc = " bstring. The getcPtr function must have the same semantics as the fgetc C"]
    #[doc = " library function (i.e., returning an integer whose value is negative when"]
    #[doc = " there are no more characters available, otherwise the value of the next"]
    #[doc = " available unsigned character from the stream.)  The intention is that parm"]
    #[doc = " would contain the stream data context/state required (similar to the role of"]
    #[doc = " the FILE* I/O stream parameter of fgets.)  If no characters are read, or"]
    #[doc = " there is some other detectable error, NULL is returned."]
    #[doc = ""]
    #[doc = " bgets will never call the getcPtr function more often than necessary to"]
    #[doc = " construct its output (including a single call, if required, to determine"]
    #[doc = " that the stream contains no more characters.)"]
    #[doc = ""]
    #[doc = " Abstracting the character stream function and terminator character allows"]
    #[doc = " for different stream devices and string formats other than '\\n'"]
    #[doc = " terminated lines in a file if desired (consider \\032 terminated email"]
    #[doc = " messages, in a UNIX mailbox for example.)"]
    #[doc = ""]
    #[doc = " For files, this function can be used analogously as fgets as follows:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " fp = fopen( ... );"]
    #[doc = " if (fp) b = bgets((bNgetc) fgetc, fp, '\\n');"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " (Note that only one terminator character can be used, and that '\\0' is"]
    #[doc = " not assumed to terminate the stream in addition to the terminator"]
    #[doc = " character. This is consistent with the semantics of fgets.)"]
    pub fn bgets(
        getcPtr: bNgetc,
        parm: *mut ::std::os::raw::c_void,
        terminator: ::std::os::raw::c_char,
    ) -> bstring;
}
extern "C" {
    #[doc = " Read an entire stream into a bstring, verbatum."]
    #[doc = ""]
    #[doc = " The readPtr function pointer is compatible with fread sematics, except that"]
    #[doc = " it need not obtain the stream data from a file. The intention is that parm"]
    #[doc = " would contain the stream data context/state required (similar to the role of"]
    #[doc = " the FILE* I/O stream parameter of fread.)"]
    #[doc = ""]
    #[doc = " Abstracting the block read function allows for block devices other than"]
    #[doc = " file streams to be read if desired. Note that there is an ANSI"]
    #[doc = " compatibility issue if \"fread\" is used directly; see the ANSI issues"]
    #[doc = " section below."]
    pub fn bread(readPtr: bNread, parm: *mut ::std::os::raw::c_void) -> bstring;
}
extern "C" {
    #[doc = " Read from a stream and concatenate to a bstring."]
    #[doc = ""]
    #[doc = " Behaves like bgets, except that it appends it results to the bstring b. The"]
    #[doc = " value 1 is returned if no characters are read before a negative result is"]
    #[doc = " returned from getcPtr. Otherwise BSTR_ERR is returned on error, and 0 is"]
    #[doc = " returned in other normal cases."]
    pub fn bgetsa(
        b: bstring,
        getcPtr: bNgetc,
        parm: *mut ::std::os::raw::c_void,
        terminator: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read from a stream and concatenate to a bstring."]
    #[doc = ""]
    #[doc = " Behaves like bgets, except that it assigns the results to the bstring b. The"]
    #[doc = " value 1 is returned if no characters are read before a negative result is"]
    #[doc = " returned from getcPtr. Otherwise BSTR_ERR is returned on error, and 0 is"]
    #[doc = " returned in other normal cases."]
    pub fn bassigngets(
        b: bstring,
        getcPtr: bNgetc,
        parm: *mut ::std::os::raw::c_void,
        terminator: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an entire stream and append it to a bstring, verbatim."]
    #[doc = ""]
    #[doc = " Behaves like bread, except that it appends it results to the bstring b."]
    #[doc = " BSTR_ERR is returned on error, otherwise 0 is returned."]
    pub fn breada(
        b: bstring,
        readPtr: bNread,
        parm: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bStream {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Wrap a given open stream (described by a fread compatible function"]
    #[doc = " pointer and stream handle) into an open bStream suitable for the bstring"]
    #[doc = " library streaming functions."]
    pub fn bsopen(readPtr: bNread, parm: *mut ::std::os::raw::c_void) -> *mut bStream;
}
extern "C" {
    #[doc = " Close the bStream, and return the handle to the stream that was"]
    #[doc = " originally used to open the given stream."]
    #[doc = ""]
    #[doc = " If s is NULL or detectably invalid, NULL will be returned."]
    pub fn bsclose(s: *mut bStream) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Set the length of the buffer used by the bStream."]
    #[doc = ""]
    #[doc = " If sz is the macro BSTR_BS_BUFF_LENGTH_GET (which is 0), the length is not"]
    #[doc = " set. If s is NULL or sz is negative, the function will return with BSTR_ERR,"]
    #[doc = " otherwise this function returns with the previous length."]
    pub fn bsbufflength(s: *mut bStream, sz: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a bstring terminated by the terminator character or the end of the"]
    #[doc = " stream from the bStream (s) and return it into the parameter r."]
    #[doc = ""]
    #[doc = " The matched terminator, if found, appears at the end of the line read. If"]
    #[doc = " the stream has been exhausted of all available data, before any can be read,"]
    #[doc = " BSTR_ERR is returned. This function may read additional characters into the"]
    #[doc = " stream buffer from the core stream that are not returned, but will be"]
    #[doc = " retained for subsequent read operations. When reading from high speed"]
    #[doc = " streams, this function can perform significantly faster than bgets."]
    pub fn bsreadln(
        b: bstring,
        s: *mut bStream,
        terminator: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a bstring terminated by any character in the terminators bstring or"]
    #[doc = " the end of the stream from the bStream (s) and return it into the"]
    #[doc = " parameter r."]
    #[doc = ""]
    #[doc = " This function may read additional characters from the core stream that are"]
    #[doc = " not returned, but will be retained for subsequent read operations."]
    pub fn bsreadlns(r: bstring, s: *mut bStream, term: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a bstring of length n (or, if it is fewer, as many bytes as is"]
    #[doc = " remaining) from the bStream."]
    #[doc = ""]
    #[doc = " This function will read the minimum required number of additional characters"]
    #[doc = " from the core stream. When the stream is at the end of the file BSTR_ERR is"]
    #[doc = " returned, otherwise BSTR_OK is returned."]
    pub fn bsread(b: bstring, s: *mut bStream, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a bstring terminated by the terminator character or the end of the"]
    #[doc = " stream from the bStream (s) and concatenate it to the parameter r."]
    #[doc = ""]
    #[doc = " The matched terminator, if found, appears at the end of the line read. If"]
    #[doc = " the stream has been exhausted of all available data, before any can be read,"]
    #[doc = " BSTR_ERR is returned. This function may read additional characters into the"]
    #[doc = " stream buffer from the core stream that are not returned, but will be"]
    #[doc = " retained for subsequent read operations. When reading from high speed"]
    #[doc = " streams, this function can perform significantly faster than bgets."]
    pub fn bsreadlna(
        b: bstring,
        s: *mut bStream,
        terminator: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a bstring terminated by any character in the terminators bstring or"]
    #[doc = " the end of the stream from the bStream (s) and concatenate it to the"]
    #[doc = " parameter r."]
    #[doc = ""]
    #[doc = " If the stream has been exhausted of all available data, before any can be"]
    #[doc = " read, BSTR_ERR is returned. This function may read additional characters"]
    #[doc = " from the core stream that are not returned, but will be retained for"]
    #[doc = " subsequent read operations."]
    pub fn bsreadlnsa(r: bstring, s: *mut bStream, term: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a bstring of length n (or, if it is fewer, as many bytes as is"]
    #[doc = " remaining) from the bStream and concatenate it to the parameter r."]
    #[doc = ""]
    #[doc = " This function will read the minimum required number of additional characters"]
    #[doc = " from the core stream. When the stream is at the end of the file BSTR_ERR is"]
    #[doc = " returned, otherwise BSTR_OK is returned."]
    pub fn bsreada(b: bstring, s: *mut bStream, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert a bstring into the bStream at the current position."]
    #[doc = ""]
    #[doc = " These characters will be read prior to those that actually come from the"]
    #[doc = " core stream."]
    pub fn bsunread(s: *mut bStream, b: bstring) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of currently buffered characters from the bStream that"]
    #[doc = " will be read prior to reads from the core stream, and append it to the"]
    #[doc = " the parameter r."]
    pub fn bspeek(r: bstring, s: *const bStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate the set of disjoint sequential substrings over the stream s"]
    #[doc = " divided by any character from the bstring splitStr."]
    #[doc = ""]
    #[doc = " The parm passed to bssplitscb is passed on to cb. If the function cb returns"]
    #[doc = " a value < 0, then further iterating is halted and this return value is"]
    #[doc = " returned by bssplitscb."]
    #[doc = ""]
    #[doc = " Note: At the point of calling the cb function, the bStream pointer is"]
    #[doc = " pointed exactly at the position right after having read the split"]
    #[doc = " character. The cb function can act on the stream by causing the bStream"]
    #[doc = " pointer to move, and bssplitscb will continue by starting the next split"]
    #[doc = " at the position of the pointer after the return from cb."]
    #[doc = ""]
    #[doc = " However, if the cb causes the bStream s to be destroyed then the cb must"]
    #[doc = " return with a negative value, otherwise bssplitscb will continue in an"]
    #[doc = " undefined manner."]
    #[doc = ""]
    #[doc = " This function is provided as way to incrementally parse through a file"]
    #[doc = " or other generic stream that in total size may otherwise exceed the"]
    #[doc = " practical or desired memory available. As with the other split callback"]
    #[doc = " based functions this is abortable and does not impose additional memory"]
    #[doc = " allocation."]
    pub fn bssplitscb(
        s: *mut bStream,
        splitStr: bstring,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                parm: *mut ::std::os::raw::c_void,
                ofs: ::std::os::raw::c_int,
                entry: bstring,
            ) -> ::std::os::raw::c_int,
        >,
        parm: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate the set of disjoint sequential substrings over the stream s"]
    #[doc = " divided by the entire substring splitStr."]
    #[doc = ""]
    #[doc = " The parm passed to bssplitstrcb is passed on to cb. If the function cb"]
    #[doc = " returns a value < 0, then further iterating is halted and this return value"]
    #[doc = " is returned by bssplitstrcb."]
    #[doc = ""]
    #[doc = " Note: At the point of calling the cb function, the bStream pointer is"]
    #[doc = " pointed exactly at the position right after having read the split"]
    #[doc = " character. The cb function can act on the stream by causing the bStream"]
    #[doc = " pointer to move, and bssplitstrcb will continue by starting the next"]
    #[doc = " split at the position of the pointer after the return from cb."]
    #[doc = ""]
    #[doc = " However, if the cb causes the bStream s to be destroyed then the cb must"]
    #[doc = " return with a negative value, otherwise bssplitscb will continue in an"]
    #[doc = " undefined manner."]
    #[doc = ""]
    #[doc = " This function is provided as way to incrementally parse through a file"]
    #[doc = " or other generic stream that in total size may otherwise exceed the"]
    #[doc = " practical or desired memory available. As with the other split callback"]
    #[doc = " based functions this is abortable and does not impose additional memory"]
    #[doc = " allocation."]
    pub fn bssplitstrcb(
        s: *mut bStream,
        splitStr: bstring,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                parm: *mut ::std::os::raw::c_void,
                ofs: ::std::os::raw::c_int,
                entry: bstring,
            ) -> ::std::os::raw::c_int,
        >,
        parm: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the defacto \"EOF\" (end of file) state of a stream (1 if the"]
    #[doc = " bStream is in an EOF state, 0 if not, and BSTR_ERR if stream is closed or"]
    #[doc = " detectably erroneous)."]
    #[doc = ""]
    #[doc = " When the readPtr callback returns a value <= 0 the stream reaches its \"EOF\""]
    #[doc = " state. Note that bunread with non-empty content will essentially turn off"]
    #[doc = " this state, and the stream will not be in its \"EOF\" state so long as its"]
    #[doc = " possible to read more data out of it."]
    #[doc = ""]
    #[doc = " Also note that the semantics of bseof() are slightly different from"]
    #[doc = " something like feof(), i.e., reaching the end of the stream does not"]
    #[doc = " necessarily guarantee that bseof() will return with a value indicating"]
    #[doc = " that this has happened. bseof() will only return indicating that it has"]
    #[doc = " reached the \"EOF\" and an attempt has been made to read past the end of"]
    #[doc = " the bStream."]
    pub fn bseof(s: *const bStream) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__high as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: size_t);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub const R_EC_R_ERR_MEM: R_EC = -1;
pub const R_EC_R_ERR_NP: R_EC = -2;
pub const R_EC_R_ERR_OUT_OF_BOUNDS: R_EC = -3;
pub const R_EC_R_ERR_VALUE: R_EC = -4;
pub type R_EC = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bstrListEmb {
    pub n: size_t,
    pub m: size_t,
    pub a: *mut tagbstring,
}
#[test]
fn bindgen_test_layout_bstrListEmb() {
    assert_eq!(
        ::std::mem::size_of::<bstrListEmb>(),
        24usize,
        concat!("Size of: ", stringify!(bstrListEmb))
    );
    assert_eq!(
        ::std::mem::align_of::<bstrListEmb>(),
        8usize,
        concat!("Alignment of ", stringify!(bstrListEmb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bstrListEmb>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bstrListEmb),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bstrListEmb>())).m as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bstrListEmb),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bstrListEmb>())).a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bstrListEmb),
            "::",
            stringify!(a)
        )
    );
}
extern "C" {
    pub fn genBstrList_create() -> *mut genBstrList;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct genBstrList {
    pub b: bstring,
    pub bl: *mut bstrListEmb,
}
#[test]
fn bindgen_test_layout_genBstrList() {
    assert_eq!(
        ::std::mem::size_of::<genBstrList>(),
        16usize,
        concat!("Size of: ", stringify!(genBstrList))
    );
    assert_eq!(
        ::std::mem::align_of::<genBstrList>(),
        8usize,
        concat!("Alignment of ", stringify!(genBstrList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<genBstrList>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(genBstrList),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<genBstrList>())).bl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(genBstrList),
            "::",
            stringify!(bl)
        )
    );
}
extern "C" {
    pub fn bstrListEmb_destroy(l: *mut bstrListEmb);
}
extern "C" {
    pub fn bsplit_noalloc(str: bstring, splicChar: ::std::os::raw::c_uchar) -> *mut bstrListEmb;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_settings {
    pub max_memory: ::std::os::raw::c_ulong,
    pub settings: ::std::os::raw::c_int,
    pub mem_alloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: size_t,
            zero: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub mem_free: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub user_data: *mut ::std::os::raw::c_void,
    pub value_extra: size_t,
}
#[test]
fn bindgen_test_layout_json_settings() {
    assert_eq!(
        ::std::mem::size_of::<json_settings>(),
        48usize,
        concat!("Size of: ", stringify!(json_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<json_settings>(),
        8usize,
        concat!("Alignment of ", stringify!(json_settings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_settings>())).max_memory as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(json_settings),
            "::",
            stringify!(max_memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_settings>())).settings as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(json_settings),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_settings>())).mem_alloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(json_settings),
            "::",
            stringify!(mem_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_settings>())).mem_free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(json_settings),
            "::",
            stringify!(mem_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_settings>())).user_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(json_settings),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_settings>())).value_extra as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(json_settings),
            "::",
            stringify!(value_extra)
        )
    );
}
pub const json_type_json_none: json_type = 0;
pub const json_type_json_object: json_type = 1;
pub const json_type_json_array: json_type = 2;
pub const json_type_json_integer: json_type = 3;
pub const json_type_json_double: json_type = 4;
pub const json_type_json_string: json_type = 5;
pub const json_type_json_boolean: json_type = 6;
pub const json_type_json_null: json_type = 7;
pub type json_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _json_value {
    pub parent: *mut _json_value,
    pub type_: json_type,
    pub u: _json_value__bindgen_ty_1,
    pub _reserved: _json_value__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _json_value__bindgen_ty_1 {
    pub boolean: ::std::os::raw::c_int,
    pub integer: int_fast64_t,
    pub dbl: f64,
    pub string: _json_value__bindgen_ty_1__bindgen_ty_1,
    pub object: _json_value__bindgen_ty_1__bindgen_ty_2,
    pub array: _json_value__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _json_value__bindgen_ty_1__bindgen_ty_1 {
    pub length: ::std::os::raw::c_uint,
    pub ptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__json_value__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_json_value__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_json_value__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1__bindgen_ty_1>())).length as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1__bindgen_ty_1>())).ptr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _json_value__bindgen_ty_1__bindgen_ty_2 {
    pub length: ::std::os::raw::c_uint,
    pub values: *mut json_object_entry,
}
#[test]
fn bindgen_test_layout__json_value__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_json_value__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_json_value__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1__bindgen_ty_2>())).length as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1__bindgen_ty_2>())).values as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _json_value__bindgen_ty_1__bindgen_ty_3 {
    pub length: ::std::os::raw::c_uint,
    pub values: *mut *mut _json_value,
}
#[test]
fn bindgen_test_layout__json_value__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<_json_value__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_json_value__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1__bindgen_ty_3>())).length as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1__bindgen_ty_3>())).values as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(values)
        )
    );
}
#[test]
fn bindgen_test_layout__json_value__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_json_value__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_json_value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_json_value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_json_value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1>())).boolean as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1>())).integer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_value__bindgen_ty_1>())).dbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1),
            "::",
            stringify!(dbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1>())).string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_1>())).object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_value__bindgen_ty_1>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _json_value__bindgen_ty_2 {
    pub next_alloc: *mut _json_value,
    pub object_mem: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__json_value__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_json_value__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_json_value__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_json_value__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_json_value__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_2>())).next_alloc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_2),
            "::",
            stringify!(next_alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_json_value__bindgen_ty_2>())).object_mem as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value__bindgen_ty_2),
            "::",
            stringify!(object_mem)
        )
    );
}
#[test]
fn bindgen_test_layout__json_value() {
    assert_eq!(
        ::std::mem::size_of::<_json_value>(),
        40usize,
        concat!("Size of: ", stringify!(_json_value))
    );
    assert_eq!(
        ::std::mem::align_of::<_json_value>(),
        8usize,
        concat!("Alignment of ", stringify!(_json_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_value>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_value>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_value>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_value>()))._reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_value),
            "::",
            stringify!(_reserved)
        )
    );
}
extern "C" {
    pub static json_value_none: _json_value;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _json_object_entry {
    pub name: *mut ::std::os::raw::c_char,
    pub name_length: ::std::os::raw::c_uint,
    pub value: *mut _json_value,
}
#[test]
fn bindgen_test_layout__json_object_entry() {
    assert_eq!(
        ::std::mem::size_of::<_json_object_entry>(),
        24usize,
        concat!("Size of: ", stringify!(_json_object_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<_json_object_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(_json_object_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_object_entry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_object_entry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_object_entry>())).name_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_object_entry),
            "::",
            stringify!(name_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_json_object_entry>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_json_object_entry),
            "::",
            stringify!(value)
        )
    );
}
pub type json_object_entry = _json_object_entry;
pub type json_value = _json_value;
extern "C" {
    pub fn json_parse(json: *const ::std::os::raw::c_char, length: size_t) -> *mut json_value;
}
extern "C" {
    pub fn json_parse_ex(
        settings: *mut json_settings,
        json: *const ::std::os::raw::c_char,
        length: size_t,
        error: *mut ::std::os::raw::c_char,
    ) -> *mut json_value;
}
extern "C" {
    pub fn json_value_free(arg1: *mut json_value);
}
extern "C" {
    pub fn json_value_free_ex(settings: *mut json_settings, arg1: *mut json_value);
}
pub type MD_CHAR = ::std::os::raw::c_char;
pub type MD_SIZE = ::std::os::raw::c_uint;
pub type MD_OFFSET = ::std::os::raw::c_uint;
pub const MD_BLOCKTYPE_MD_BLOCK_DOC: MD_BLOCKTYPE = 0;
pub const MD_BLOCKTYPE_MD_BLOCK_QUOTE: MD_BLOCKTYPE = 1;
pub const MD_BLOCKTYPE_MD_BLOCK_UL: MD_BLOCKTYPE = 2;
pub const MD_BLOCKTYPE_MD_BLOCK_OL: MD_BLOCKTYPE = 3;
pub const MD_BLOCKTYPE_MD_BLOCK_LI: MD_BLOCKTYPE = 4;
pub const MD_BLOCKTYPE_MD_BLOCK_HR: MD_BLOCKTYPE = 5;
pub const MD_BLOCKTYPE_MD_BLOCK_H: MD_BLOCKTYPE = 6;
pub const MD_BLOCKTYPE_MD_BLOCK_CODE: MD_BLOCKTYPE = 7;
pub const MD_BLOCKTYPE_MD_BLOCK_HTML: MD_BLOCKTYPE = 8;
pub const MD_BLOCKTYPE_MD_BLOCK_P: MD_BLOCKTYPE = 9;
pub const MD_BLOCKTYPE_MD_BLOCK_TABLE: MD_BLOCKTYPE = 10;
pub const MD_BLOCKTYPE_MD_BLOCK_THEAD: MD_BLOCKTYPE = 11;
pub const MD_BLOCKTYPE_MD_BLOCK_TBODY: MD_BLOCKTYPE = 12;
pub const MD_BLOCKTYPE_MD_BLOCK_TR: MD_BLOCKTYPE = 13;
pub const MD_BLOCKTYPE_MD_BLOCK_TH: MD_BLOCKTYPE = 14;
pub const MD_BLOCKTYPE_MD_BLOCK_TD: MD_BLOCKTYPE = 15;
pub type MD_BLOCKTYPE = u32;
pub const MD_SPANTYPE_MD_SPAN_EM: MD_SPANTYPE = 0;
pub const MD_SPANTYPE_MD_SPAN_STRONG: MD_SPANTYPE = 1;
pub const MD_SPANTYPE_MD_SPAN_A: MD_SPANTYPE = 2;
pub const MD_SPANTYPE_MD_SPAN_IMG: MD_SPANTYPE = 3;
pub const MD_SPANTYPE_MD_SPAN_CODE: MD_SPANTYPE = 4;
pub const MD_SPANTYPE_MD_SPAN_DEL: MD_SPANTYPE = 5;
pub const MD_SPANTYPE_MD_SPAN_LATEXMATH: MD_SPANTYPE = 6;
pub const MD_SPANTYPE_MD_SPAN_LATEXMATH_DISPLAY: MD_SPANTYPE = 7;
pub const MD_SPANTYPE_MD_SPAN_WIKILINK: MD_SPANTYPE = 8;
pub const MD_SPANTYPE_MD_SPAN_U: MD_SPANTYPE = 9;
pub type MD_SPANTYPE = u32;
pub const MD_TEXTTYPE_MD_TEXT_NORMAL: MD_TEXTTYPE = 0;
pub const MD_TEXTTYPE_MD_TEXT_NULLCHAR: MD_TEXTTYPE = 1;
pub const MD_TEXTTYPE_MD_TEXT_BR: MD_TEXTTYPE = 2;
pub const MD_TEXTTYPE_MD_TEXT_SOFTBR: MD_TEXTTYPE = 3;
pub const MD_TEXTTYPE_MD_TEXT_ENTITY: MD_TEXTTYPE = 4;
pub const MD_TEXTTYPE_MD_TEXT_CODE: MD_TEXTTYPE = 5;
pub const MD_TEXTTYPE_MD_TEXT_HTML: MD_TEXTTYPE = 6;
pub const MD_TEXTTYPE_MD_TEXT_LATEXMATH: MD_TEXTTYPE = 7;
pub type MD_TEXTTYPE = u32;
pub const MD_ALIGN_MD_ALIGN_DEFAULT: MD_ALIGN = 0;
pub const MD_ALIGN_MD_ALIGN_LEFT: MD_ALIGN = 1;
pub const MD_ALIGN_MD_ALIGN_CENTER: MD_ALIGN = 2;
pub const MD_ALIGN_MD_ALIGN_RIGHT: MD_ALIGN = 3;
pub type MD_ALIGN = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_ATTRIBUTE {
    pub text: *const MD_CHAR,
    pub size: MD_SIZE,
    pub substr_types: *const MD_TEXTTYPE,
    pub substr_offsets: *const MD_OFFSET,
}
#[test]
fn bindgen_test_layout_MD_ATTRIBUTE() {
    assert_eq!(
        ::std::mem::size_of::<MD_ATTRIBUTE>(),
        32usize,
        concat!("Size of: ", stringify!(MD_ATTRIBUTE))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_ATTRIBUTE>(),
        8usize,
        concat!("Alignment of ", stringify!(MD_ATTRIBUTE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_ATTRIBUTE>())).text as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_ATTRIBUTE),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_ATTRIBUTE>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_ATTRIBUTE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_ATTRIBUTE>())).substr_types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_ATTRIBUTE),
            "::",
            stringify!(substr_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_ATTRIBUTE>())).substr_offsets as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_ATTRIBUTE),
            "::",
            stringify!(substr_offsets)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_BLOCK_UL_DETAIL {
    pub is_tight: ::std::os::raw::c_int,
    pub mark: MD_CHAR,
}
#[test]
fn bindgen_test_layout_MD_BLOCK_UL_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_BLOCK_UL_DETAIL>(),
        8usize,
        concat!("Size of: ", stringify!(MD_BLOCK_UL_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_BLOCK_UL_DETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(MD_BLOCK_UL_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_UL_DETAIL>())).is_tight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_UL_DETAIL),
            "::",
            stringify!(is_tight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_UL_DETAIL>())).mark as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_UL_DETAIL),
            "::",
            stringify!(mark)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_BLOCK_OL_DETAIL {
    pub start: ::std::os::raw::c_uint,
    pub is_tight: ::std::os::raw::c_int,
    pub mark_delimiter: MD_CHAR,
}
#[test]
fn bindgen_test_layout_MD_BLOCK_OL_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_BLOCK_OL_DETAIL>(),
        12usize,
        concat!("Size of: ", stringify!(MD_BLOCK_OL_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_BLOCK_OL_DETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(MD_BLOCK_OL_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_OL_DETAIL>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_OL_DETAIL),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_OL_DETAIL>())).is_tight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_OL_DETAIL),
            "::",
            stringify!(is_tight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MD_BLOCK_OL_DETAIL>())).mark_delimiter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_OL_DETAIL),
            "::",
            stringify!(mark_delimiter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_BLOCK_LI_DETAIL {
    pub is_task: ::std::os::raw::c_int,
    pub task_mark: MD_CHAR,
    pub task_mark_offset: MD_OFFSET,
}
#[test]
fn bindgen_test_layout_MD_BLOCK_LI_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_BLOCK_LI_DETAIL>(),
        12usize,
        concat!("Size of: ", stringify!(MD_BLOCK_LI_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_BLOCK_LI_DETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(MD_BLOCK_LI_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_LI_DETAIL>())).is_task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_LI_DETAIL),
            "::",
            stringify!(is_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_LI_DETAIL>())).task_mark as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_LI_DETAIL),
            "::",
            stringify!(task_mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MD_BLOCK_LI_DETAIL>())).task_mark_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_LI_DETAIL),
            "::",
            stringify!(task_mark_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_BLOCK_H_DETAIL {
    pub level: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_MD_BLOCK_H_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_BLOCK_H_DETAIL>(),
        4usize,
        concat!("Size of: ", stringify!(MD_BLOCK_H_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_BLOCK_H_DETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(MD_BLOCK_H_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_H_DETAIL>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_H_DETAIL),
            "::",
            stringify!(level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_BLOCK_CODE_DETAIL {
    pub info: MD_ATTRIBUTE,
    pub lang: MD_ATTRIBUTE,
    pub fence_char: MD_CHAR,
}
#[test]
fn bindgen_test_layout_MD_BLOCK_CODE_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_BLOCK_CODE_DETAIL>(),
        72usize,
        concat!("Size of: ", stringify!(MD_BLOCK_CODE_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_BLOCK_CODE_DETAIL>(),
        8usize,
        concat!("Alignment of ", stringify!(MD_BLOCK_CODE_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_CODE_DETAIL>())).info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_CODE_DETAIL),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_CODE_DETAIL>())).lang as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_CODE_DETAIL),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_CODE_DETAIL>())).fence_char as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_CODE_DETAIL),
            "::",
            stringify!(fence_char)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_BLOCK_TABLE_DETAIL {
    pub col_count: ::std::os::raw::c_uint,
    pub head_row_count: ::std::os::raw::c_uint,
    pub body_row_count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_MD_BLOCK_TABLE_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_BLOCK_TABLE_DETAIL>(),
        12usize,
        concat!("Size of: ", stringify!(MD_BLOCK_TABLE_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_BLOCK_TABLE_DETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(MD_BLOCK_TABLE_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_TABLE_DETAIL>())).col_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_TABLE_DETAIL),
            "::",
            stringify!(col_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MD_BLOCK_TABLE_DETAIL>())).head_row_count as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_TABLE_DETAIL),
            "::",
            stringify!(head_row_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MD_BLOCK_TABLE_DETAIL>())).body_row_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_TABLE_DETAIL),
            "::",
            stringify!(body_row_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_BLOCK_TD_DETAIL {
    pub align: MD_ALIGN,
}
#[test]
fn bindgen_test_layout_MD_BLOCK_TD_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_BLOCK_TD_DETAIL>(),
        4usize,
        concat!("Size of: ", stringify!(MD_BLOCK_TD_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_BLOCK_TD_DETAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(MD_BLOCK_TD_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_BLOCK_TD_DETAIL>())).align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_BLOCK_TD_DETAIL),
            "::",
            stringify!(align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_SPAN_A_DETAIL {
    pub href: MD_ATTRIBUTE,
    pub title: MD_ATTRIBUTE,
}
#[test]
fn bindgen_test_layout_MD_SPAN_A_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_SPAN_A_DETAIL>(),
        64usize,
        concat!("Size of: ", stringify!(MD_SPAN_A_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_SPAN_A_DETAIL>(),
        8usize,
        concat!("Alignment of ", stringify!(MD_SPAN_A_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_SPAN_A_DETAIL>())).href as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_SPAN_A_DETAIL),
            "::",
            stringify!(href)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_SPAN_A_DETAIL>())).title as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_SPAN_A_DETAIL),
            "::",
            stringify!(title)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_SPAN_IMG_DETAIL {
    pub src: MD_ATTRIBUTE,
    pub title: MD_ATTRIBUTE,
}
#[test]
fn bindgen_test_layout_MD_SPAN_IMG_DETAIL() {
    assert_eq!(
        ::std::mem::size_of::<MD_SPAN_IMG_DETAIL>(),
        64usize,
        concat!("Size of: ", stringify!(MD_SPAN_IMG_DETAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_SPAN_IMG_DETAIL>(),
        8usize,
        concat!("Alignment of ", stringify!(MD_SPAN_IMG_DETAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_SPAN_IMG_DETAIL>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_SPAN_IMG_DETAIL),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_SPAN_IMG_DETAIL>())).title as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_SPAN_IMG_DETAIL),
            "::",
            stringify!(title)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_SPAN_WIKILINK {
    pub target: MD_ATTRIBUTE,
}
#[test]
fn bindgen_test_layout_MD_SPAN_WIKILINK() {
    assert_eq!(
        ::std::mem::size_of::<MD_SPAN_WIKILINK>(),
        32usize,
        concat!("Size of: ", stringify!(MD_SPAN_WIKILINK))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_SPAN_WIKILINK>(),
        8usize,
        concat!("Alignment of ", stringify!(MD_SPAN_WIKILINK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_SPAN_WIKILINK>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_SPAN_WIKILINK),
            "::",
            stringify!(target)
        )
    );
}
pub type MD_SPAN_WIKILINK_DETAIL = MD_SPAN_WIKILINK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD_PARSER {
    pub abi_version: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub enter_block: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: MD_BLOCKTYPE,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub leave_block: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: MD_BLOCKTYPE,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub enter_span: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: MD_SPANTYPE,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub leave_span: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: MD_SPANTYPE,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: MD_TEXTTYPE,
            arg2: *const MD_CHAR,
            arg3: MD_SIZE,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub debug_log: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    pub syntax: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_MD_PARSER() {
    assert_eq!(
        ::std::mem::size_of::<MD_PARSER>(),
        64usize,
        concat!("Size of: ", stringify!(MD_PARSER))
    );
    assert_eq!(
        ::std::mem::align_of::<MD_PARSER>(),
        8usize,
        concat!("Alignment of ", stringify!(MD_PARSER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).abi_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(abi_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).enter_block as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(enter_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).leave_block as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(leave_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).enter_span as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(enter_span)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).leave_span as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(leave_span)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).text as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).debug_log as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(debug_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MD_PARSER>())).syntax as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MD_PARSER),
            "::",
            stringify!(syntax)
        )
    );
}
pub type MD_RENDERER = MD_PARSER;
extern "C" {
    pub fn md_parse(
        text: *const MD_CHAR,
        size: MD_SIZE,
        parser: *const MD_PARSER,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sqlite3_version: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn sqlite3_libversion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_sourceid() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_libversion_number() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_compileoption_used(
        zOptName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_compileoption_get(N: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_threadsafe() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3 {
    _unused: [u8; 0],
}
pub type sqlite_int64 = ::std::os::raw::c_longlong;
pub type sqlite_uint64 = ::std::os::raw::c_ulonglong;
pub type sqlite3_int64 = sqlite_int64;
pub type sqlite3_uint64 = sqlite_uint64;
extern "C" {
    pub fn sqlite3_close(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_close_v2(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
pub type sqlite3_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn sqlite3_exec(
        arg1: *mut sqlite3,
        sql: *const ::std::os::raw::c_char,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut ::std::os::raw::c_char,
                arg4: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        arg2: *mut ::std::os::raw::c_void,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_file {
    pub pMethods: *const sqlite3_io_methods,
}
#[test]
fn bindgen_test_layout_sqlite3_file() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_file>(),
        8usize,
        concat!("Size of: ", stringify!(sqlite3_file))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_file>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_file))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_file>())).pMethods as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_file),
            "::",
            stringify!(pMethods)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_io_methods {
    pub iVersion: ::std::os::raw::c_int,
    pub xClose: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,
    >,
    pub xRead: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: *mut ::std::os::raw::c_void,
            iAmt: ::std::os::raw::c_int,
            iOfst: sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xWrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: *const ::std::os::raw::c_void,
            iAmt: ::std::os::raw::c_int,
            iOfst: sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xTruncate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file, size: sqlite3_int64) -> ::std::os::raw::c_int,
    >,
    pub xSync: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFileSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            pSize: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xUnlock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCheckReservedLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            pResOut: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFileControl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            op: ::std::os::raw::c_int,
            pArg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSectorSize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,
    >,
    pub xDeviceCharacteristics: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::std::os::raw::c_int,
    >,
    pub xShmMap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            iPg: ::std::os::raw::c_int,
            pgsz: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xShmLock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            offset: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xShmBarrier: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_file)>,
    pub xShmUnmap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            deleteFlag: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            iOfst: sqlite3_int64,
            iAmt: ::std::os::raw::c_int,
            pp: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xUnfetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_file,
            iOfst: sqlite3_int64,
            p: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_sqlite3_io_methods() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_io_methods>(),
        152usize,
        concat!("Size of: ", stringify!(sqlite3_io_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_io_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_io_methods))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).iVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(iVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xClose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xClose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xRead as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xWrite as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xTruncate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xTruncate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xSync as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xSync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xFileSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xFileSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xLock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xUnlock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xUnlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_io_methods>())).xCheckReservedLock as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xCheckReservedLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xFileControl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xFileControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xSectorSize as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xSectorSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_io_methods>())).xDeviceCharacteristics as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xDeviceCharacteristics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xShmMap as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xShmMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xShmLock as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xShmLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xShmBarrier as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xShmBarrier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xShmUnmap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xShmUnmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xFetch as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xFetch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_io_methods>())).xUnfetch as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_io_methods),
            "::",
            stringify!(xUnfetch)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_api_routines {
    _unused: [u8; 0],
}
pub type sqlite3_syscall_ptr = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_vfs {
    pub iVersion: ::std::os::raw::c_int,
    pub szOsFile: ::std::os::raw::c_int,
    pub mxPathname: ::std::os::raw::c_int,
    pub pNext: *mut sqlite3_vfs,
    pub zName: *const ::std::os::raw::c_char,
    pub pAppData: *mut ::std::os::raw::c_void,
    pub xOpen: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            arg2: *mut sqlite3_file,
            flags: ::std::os::raw::c_int,
            pOutFlags: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDelete: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            syncDir: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xAccess: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            pResOut: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFullPathname: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            nOut: ::std::os::raw::c_int,
            zOut: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDlOpen: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zFilename: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xDlError: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            nByte: ::std::os::raw::c_int,
            zErrMsg: *mut ::std::os::raw::c_char,
        ),
    >,
    pub xDlSym: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            arg2: *mut ::std::os::raw::c_void,
            zSymbol: *const ::std::os::raw::c_char,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_vfs,
                arg2: *mut ::std::os::raw::c_void,
                zSymbol: *const ::std::os::raw::c_char,
            ),
        >,
    >,
    pub xDlClose: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut ::std::os::raw::c_void),
    >,
    pub xRandomness: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            nByte: ::std::os::raw::c_int,
            zOut: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSleep: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            microseconds: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCurrentTime: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut f64) -> ::std::os::raw::c_int,
    >,
    pub xGetLastError: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCurrentTimeInt64: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            arg2: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSetSystemCall: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
            arg2: sqlite3_syscall_ptr,
        ) -> ::std::os::raw::c_int,
    >,
    pub xGetSystemCall: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
        ) -> sqlite3_syscall_ptr,
    >,
    pub xNextSystemCall: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vfs,
            zName: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_sqlite3_vfs() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_vfs>(),
        168usize,
        concat!("Size of: ", stringify!(sqlite3_vfs))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_vfs>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_vfs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).iVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(iVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).szOsFile as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(szOsFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).mxPathname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(mxPathname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).pNext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).zName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(zName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).pAppData as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(pAppData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xOpen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xOpen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xDelete as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xAccess as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xFullPathname as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xFullPathname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xDlOpen as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xDlOpen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xDlError as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xDlError)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xDlSym as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xDlSym)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xDlClose as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xDlClose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xRandomness as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xRandomness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xSleep as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xSleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xCurrentTime as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xCurrentTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xGetLastError as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xGetLastError)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xCurrentTimeInt64 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xCurrentTimeInt64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xSetSystemCall as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xSetSystemCall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xGetSystemCall as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xGetSystemCall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vfs>())).xNextSystemCall as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vfs),
            "::",
            stringify!(xNextSystemCall)
        )
    );
}
extern "C" {
    pub fn sqlite3_initialize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_shutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_os_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_os_end() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_config(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_db_config(
        arg1: *mut sqlite3,
        op: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_mem_methods {
    pub xMalloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void,
    >,
    pub xFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub xRealloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xSize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xRoundup: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub xInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xShutdown: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub pAppData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sqlite3_mem_methods() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_mem_methods>(),
        64usize,
        concat!("Size of: ", stringify!(sqlite3_mem_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_mem_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_mem_methods))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).xMalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(xMalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).xFree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(xFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).xRealloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(xRealloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).xSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(xSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).xRoundup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(xRoundup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).xInit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(xInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).xShutdown as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(xShutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mem_methods>())).pAppData as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mem_methods),
            "::",
            stringify!(pAppData)
        )
    );
}
extern "C" {
    pub fn sqlite3_extended_result_codes(
        arg1: *mut sqlite3,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_last_insert_rowid(arg1: *mut sqlite3) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_set_last_insert_rowid(arg1: *mut sqlite3, arg2: sqlite3_int64);
}
extern "C" {
    pub fn sqlite3_changes(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_changes64(arg1: *mut sqlite3) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_total_changes(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_total_changes64(arg1: *mut sqlite3) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_interrupt(arg1: *mut sqlite3);
}
extern "C" {
    pub fn sqlite3_complete(sql: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_complete16(sql: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_busy_handler(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_busy_timeout(
        arg1: *mut sqlite3,
        ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_get_table(
        db: *mut sqlite3,
        zSql: *const ::std::os::raw::c_char,
        pazResult: *mut *mut *mut ::std::os::raw::c_char,
        pnRow: *mut ::std::os::raw::c_int,
        pnColumn: *mut ::std::os::raw::c_int,
        pzErrmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_free_table(result: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sqlite3_mprintf(arg1: *const ::std::os::raw::c_char, ...)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_vmprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_snprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_vsnprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_malloc(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_malloc64(arg1: sqlite3_uint64) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_realloc64(
        arg1: *mut ::std::os::raw::c_void,
        arg2: sqlite3_uint64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sqlite3_msize(arg1: *mut ::std::os::raw::c_void) -> sqlite3_uint64;
}
extern "C" {
    pub fn sqlite3_memory_used() -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_memory_highwater(resetFlag: ::std::os::raw::c_int) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_randomness(N: ::std::os::raw::c_int, P: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sqlite3_set_authorizer(
        arg1: *mut sqlite3,
        xAuth: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *const ::std::os::raw::c_char,
                arg5: *const ::std::os::raw::c_char,
                arg6: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        pUserData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_trace(
        arg1: *mut sqlite3,
        xTrace: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
            ),
        >,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_profile(
        arg1: *mut sqlite3,
        xProfile: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: sqlite3_uint64,
            ),
        >,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_trace_v2(
        arg1: *mut sqlite3,
        uMask: ::std::os::raw::c_uint,
        xCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_uint,
                arg2: *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
                arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pCtx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_progress_handler(
        arg1: *mut sqlite3,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        arg4: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn sqlite3_open(
        filename: *const ::std::os::raw::c_char,
        ppDb: *mut *mut sqlite3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_open16(
        filename: *const ::std::os::raw::c_void,
        ppDb: *mut *mut sqlite3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_open_v2(
        filename: *const ::std::os::raw::c_char,
        ppDb: *mut *mut sqlite3,
        flags: ::std::os::raw::c_int,
        zVfs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_uri_parameter(
        zFilename: *const ::std::os::raw::c_char,
        zParam: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_uri_boolean(
        zFile: *const ::std::os::raw::c_char,
        zParam: *const ::std::os::raw::c_char,
        bDefault: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_uri_int64(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: sqlite3_int64,
    ) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_uri_key(
        zFilename: *const ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_filename_database(
        arg1: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_filename_journal(
        arg1: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_filename_wal(
        arg1: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_database_file_object(arg1: *const ::std::os::raw::c_char) -> *mut sqlite3_file;
}
extern "C" {
    pub fn sqlite3_create_filename(
        zDatabase: *const ::std::os::raw::c_char,
        zJournal: *const ::std::os::raw::c_char,
        zWal: *const ::std::os::raw::c_char,
        nParam: ::std::os::raw::c_int,
        azParam: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_free_filename(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sqlite3_errcode(db: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_extended_errcode(db: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_errmsg(arg1: *mut sqlite3) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_errmsg16(arg1: *mut sqlite3) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_errstr(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_error_offset(db: *mut sqlite3) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_stmt {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sqlite3_limit(
        arg1: *mut sqlite3,
        id: ::std::os::raw::c_int,
        newVal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_prepare(
        db: *mut sqlite3,
        zSql: *const ::std::os::raw::c_char,
        nByte: ::std::os::raw::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_prepare_v2(
        db: *mut sqlite3,
        zSql: *const ::std::os::raw::c_char,
        nByte: ::std::os::raw::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_prepare_v3(
        db: *mut sqlite3,
        zSql: *const ::std::os::raw::c_char,
        nByte: ::std::os::raw::c_int,
        prepFlags: ::std::os::raw::c_uint,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_prepare16(
        db: *mut sqlite3,
        zSql: *const ::std::os::raw::c_void,
        nByte: ::std::os::raw::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_prepare16_v2(
        db: *mut sqlite3,
        zSql: *const ::std::os::raw::c_void,
        nByte: ::std::os::raw::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_prepare16_v3(
        db: *mut sqlite3,
        zSql: *const ::std::os::raw::c_void,
        nByte: ::std::os::raw::c_int,
        prepFlags: ::std::os::raw::c_uint,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_stmt_busy(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_value {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_context {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sqlite3_bind_blob(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_blob64(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_void,
        arg4: sqlite3_uint64,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_double(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_int(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_int64(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: sqlite3_int64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_null(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_text(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_text16(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_text64(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: sqlite3_uint64,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        encoding: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_value(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *const sqlite3_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_pointer(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_zeroblob(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_zeroblob64(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
        arg3: sqlite3_uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_parameter_count(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_bind_parameter_name(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_bind_parameter_index(
        arg1: *mut sqlite3_stmt,
        zName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_clear_bindings(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_column_name(
        arg1: *mut sqlite3_stmt,
        N: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_column_name16(
        arg1: *mut sqlite3_stmt,
        N: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_column_database_name(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_column_database_name16(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_column_table_name(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_column_table_name16(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_column_origin_name(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_column_origin_name16(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_column_decltype(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_column_decltype16(
        arg1: *mut sqlite3_stmt,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_step(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_data_count(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_column_blob(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_column_double(arg1: *mut sqlite3_stmt, iCol: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn sqlite3_column_int(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_column_int64(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_column_text(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn sqlite3_column_text16(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_column_value(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> *mut sqlite3_value;
}
extern "C" {
    pub fn sqlite3_column_bytes(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_column_bytes16(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_column_type(
        arg1: *mut sqlite3_stmt,
        iCol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_create_function(
        db: *mut sqlite3,
        zFunctionName: *const ::std::os::raw::c_char,
        nArg: ::std::os::raw::c_int,
        eTextRep: ::std::os::raw::c_int,
        pApp: *mut ::std::os::raw::c_void,
        xFunc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_create_function16(
        db: *mut sqlite3,
        zFunctionName: *const ::std::os::raw::c_void,
        nArg: ::std::os::raw::c_int,
        eTextRep: ::std::os::raw::c_int,
        pApp: *mut ::std::os::raw::c_void,
        xFunc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_create_function_v2(
        db: *mut sqlite3,
        zFunctionName: *const ::std::os::raw::c_char,
        nArg: ::std::os::raw::c_int,
        eTextRep: ::std::os::raw::c_int,
        pApp: *mut ::std::os::raw::c_void,
        xFunc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_create_window_function(
        db: *mut sqlite3,
        zFunctionName: *const ::std::os::raw::c_char,
        nArg: ::std::os::raw::c_int,
        eTextRep: ::std::os::raw::c_int,
        pApp: *mut ::std::os::raw::c_void,
        xStep: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xFinal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        xValue: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
        xInverse: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_context,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ),
        >,
        xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_aggregate_count(arg1: *mut sqlite3_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_expired(arg1: *mut sqlite3_stmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_transfer_bindings(
        arg1: *mut sqlite3_stmt,
        arg2: *mut sqlite3_stmt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_global_recover() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_thread_cleanup();
}
extern "C" {
    pub fn sqlite3_memory_alarm(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: sqlite3_int64,
                arg3: ::std::os::raw::c_int,
            ),
        >,
        arg2: *mut ::std::os::raw::c_void,
        arg3: sqlite3_int64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_blob(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_value_double(arg1: *mut sqlite3_value) -> f64;
}
extern "C" {
    pub fn sqlite3_value_int(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_int64(arg1: *mut sqlite3_value) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_value_pointer(
        arg1: *mut sqlite3_value,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_value_text(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn sqlite3_value_text16(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_value_text16le(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_value_text16be(arg1: *mut sqlite3_value) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_value_bytes(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_bytes16(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_type(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_numeric_type(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_nochange(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_frombind(arg1: *mut sqlite3_value) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_value_subtype(arg1: *mut sqlite3_value) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sqlite3_value_dup(arg1: *const sqlite3_value) -> *mut sqlite3_value;
}
extern "C" {
    pub fn sqlite3_value_free(arg1: *mut sqlite3_value);
}
extern "C" {
    pub fn sqlite3_aggregate_context(
        arg1: *mut sqlite3_context,
        nBytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_user_data(arg1: *mut sqlite3_context) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_context_db_handle(arg1: *mut sqlite3_context) -> *mut sqlite3;
}
extern "C" {
    pub fn sqlite3_get_auxdata(
        arg1: *mut sqlite3_context,
        N: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_set_auxdata(
        arg1: *mut sqlite3_context,
        N: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
pub type sqlite3_destructor_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn sqlite3_result_blob(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sqlite3_result_blob64(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: sqlite3_uint64,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sqlite3_result_double(arg1: *mut sqlite3_context, arg2: f64);
}
extern "C" {
    pub fn sqlite3_result_error(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sqlite3_result_error16(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sqlite3_result_error_toobig(arg1: *mut sqlite3_context);
}
extern "C" {
    pub fn sqlite3_result_error_nomem(arg1: *mut sqlite3_context);
}
extern "C" {
    pub fn sqlite3_result_error_code(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sqlite3_result_int(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sqlite3_result_int64(arg1: *mut sqlite3_context, arg2: sqlite3_int64);
}
extern "C" {
    pub fn sqlite3_result_null(arg1: *mut sqlite3_context);
}
extern "C" {
    pub fn sqlite3_result_text(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sqlite3_result_text64(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_char,
        arg3: sqlite3_uint64,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        encoding: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn sqlite3_result_text16(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sqlite3_result_text16le(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sqlite3_result_text16be(
        arg1: *mut sqlite3_context,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sqlite3_result_value(arg1: *mut sqlite3_context, arg2: *mut sqlite3_value);
}
extern "C" {
    pub fn sqlite3_result_pointer(
        arg1: *mut sqlite3_context,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sqlite3_result_zeroblob(arg1: *mut sqlite3_context, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sqlite3_result_zeroblob64(
        arg1: *mut sqlite3_context,
        n: sqlite3_uint64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_result_subtype(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn sqlite3_create_collation(
        arg1: *mut sqlite3,
        zName: *const ::std::os::raw::c_char,
        eTextRep: ::std::os::raw::c_int,
        pArg: *mut ::std::os::raw::c_void,
        xCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
                arg4: ::std::os::raw::c_int,
                arg5: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_create_collation_v2(
        arg1: *mut sqlite3,
        zName: *const ::std::os::raw::c_char,
        eTextRep: ::std::os::raw::c_int,
        pArg: *mut ::std::os::raw::c_void,
        xCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
                arg4: ::std::os::raw::c_int,
                arg5: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_create_collation16(
        arg1: *mut sqlite3,
        zName: *const ::std::os::raw::c_void,
        eTextRep: ::std::os::raw::c_int,
        pArg: *mut ::std::os::raw::c_void,
        xCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
                arg4: ::std::os::raw::c_int,
                arg5: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_collation_needed(
        arg1: *mut sqlite3,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut sqlite3,
                eTextRep: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_collation_needed16(
        arg1: *mut sqlite3,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut sqlite3,
                eTextRep: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_void,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_sleep(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sqlite3_temp_directory: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut sqlite3_data_directory: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_win32_set_directory(
        type_: ::std::os::raw::c_ulong,
        zValue: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_win32_set_directory8(
        type_: ::std::os::raw::c_ulong,
        zValue: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_win32_set_directory16(
        type_: ::std::os::raw::c_ulong,
        zValue: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_get_autocommit(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_db_handle(arg1: *mut sqlite3_stmt) -> *mut sqlite3;
}
extern "C" {
    pub fn sqlite3_db_name(
        db: *mut sqlite3,
        N: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_db_filename(
        db: *mut sqlite3,
        zDbName: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_db_readonly(
        db: *mut sqlite3,
        zDbName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_txn_state(
        arg1: *mut sqlite3,
        zSchema: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_next_stmt(pDb: *mut sqlite3, pStmt: *mut sqlite3_stmt) -> *mut sqlite3_stmt;
}
extern "C" {
    pub fn sqlite3_commit_hook(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_rollback_hook(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_autovacuum_pages(
        db: *mut sqlite3,
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_uint,
                arg4: ::std::os::raw::c_uint,
                arg5: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint,
        >,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_update_hook(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *const ::std::os::raw::c_char,
                arg5: sqlite3_int64,
            ),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_enable_shared_cache(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_release_memory(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_db_release_memory(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_soft_heap_limit64(N: sqlite3_int64) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_hard_heap_limit64(N: sqlite3_int64) -> sqlite3_int64;
}
extern "C" {
    pub fn sqlite3_soft_heap_limit(N: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sqlite3_table_column_metadata(
        db: *mut sqlite3,
        zDbName: *const ::std::os::raw::c_char,
        zTableName: *const ::std::os::raw::c_char,
        zColumnName: *const ::std::os::raw::c_char,
        pzDataType: *mut *const ::std::os::raw::c_char,
        pzCollSeq: *mut *const ::std::os::raw::c_char,
        pNotNull: *mut ::std::os::raw::c_int,
        pPrimaryKey: *mut ::std::os::raw::c_int,
        pAutoinc: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_load_extension(
        db: *mut sqlite3,
        zFile: *const ::std::os::raw::c_char,
        zProc: *const ::std::os::raw::c_char,
        pzErrMsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_enable_load_extension(
        db: *mut sqlite3,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_auto_extension(
        xEntryPoint: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_cancel_auto_extension(
        xEntryPoint: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_reset_auto_extension();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_module {
    pub iVersion: ::std::os::raw::c_int,
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            pAux: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_int,
            argv: *const *const ::std::os::raw::c_char,
            ppVTab: *mut *mut sqlite3_vtab,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xConnect: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3,
            pAux: *mut ::std::os::raw::c_void,
            argc: ::std::os::raw::c_int,
            argv: *const *const ::std::os::raw::c_char,
            ppVTab: *mut *mut sqlite3_vtab,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xBestIndex: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: *mut sqlite3_index_info,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDisconnect: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xDestroy: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xOpen: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            ppCursor: *mut *mut sqlite3_vtab_cursor,
        ) -> ::std::os::raw::c_int,
    >,
    pub xClose: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,
    >,
    pub xFilter: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab_cursor,
            idxNum: ::std::os::raw::c_int,
            idxStr: *const ::std::os::raw::c_char,
            argc: ::std::os::raw::c_int,
            argv: *mut *mut sqlite3_value,
        ) -> ::std::os::raw::c_int,
    >,
    pub xNext: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,
    >,
    pub xEof: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::std::os::raw::c_int,
    >,
    pub xColumn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab_cursor,
            arg2: *mut sqlite3_context,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRowid: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab_cursor,
            pRowid: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xUpdate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_vtab,
            arg2: ::std::os::raw::c_int,
            arg3: *mut *mut sqlite3_value,
            arg4: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xBegin: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xSync: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xCommit: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xRollback: ::std::option::Option<
        unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::std::os::raw::c_int,
    >,
    pub xFindFunction: ::std::option::Option<
        unsafe extern "C" fn(
            pVtab: *mut sqlite3_vtab,
            nArg: ::std::os::raw::c_int,
            zName: *const ::std::os::raw::c_char,
            pxFunc: *mut ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_context,
                    arg2: ::std::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ),
            >,
            ppArg: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRename: ::std::option::Option<
        unsafe extern "C" fn(
            pVtab: *mut sqlite3_vtab,
            zNew: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSavepoint: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRelease: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRollbackTo: ::std::option::Option<
        unsafe extern "C" fn(
            pVTab: *mut sqlite3_vtab,
            arg1: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xShadowName: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_sqlite3_module() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_module>(),
        192usize,
        concat!("Size of: ", stringify!(sqlite3_module))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_module>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_module))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).iVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(iVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xCreate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xCreate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xConnect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xConnect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xBestIndex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xBestIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xDisconnect as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xDisconnect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xDestroy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xDestroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xOpen as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xOpen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xClose as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xClose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xFilter as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xNext as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xEof as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xEof)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xColumn as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xColumn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xRowid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xRowid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xUpdate as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xBegin as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xBegin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xSync as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xSync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xCommit as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xCommit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xRollback as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xRollback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xFindFunction as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xFindFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xRename as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xRename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xSavepoint as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xSavepoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xRelease as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xRelease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xRollbackTo as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xRollbackTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_module>())).xShadowName as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_module),
            "::",
            stringify!(xShadowName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_info {
    pub nConstraint: ::std::os::raw::c_int,
    pub aConstraint: *mut sqlite3_index_info_sqlite3_index_constraint,
    pub nOrderBy: ::std::os::raw::c_int,
    pub aOrderBy: *mut sqlite3_index_info_sqlite3_index_orderby,
    pub aConstraintUsage: *mut sqlite3_index_info_sqlite3_index_constraint_usage,
    pub idxNum: ::std::os::raw::c_int,
    pub idxStr: *mut ::std::os::raw::c_char,
    pub needToFreeIdxStr: ::std::os::raw::c_int,
    pub orderByConsumed: ::std::os::raw::c_int,
    pub estimatedCost: f64,
    pub estimatedRows: sqlite3_int64,
    pub idxFlags: ::std::os::raw::c_int,
    pub colUsed: sqlite3_uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_info_sqlite3_index_constraint {
    pub iColumn: ::std::os::raw::c_int,
    pub op: ::std::os::raw::c_uchar,
    pub usable: ::std::os::raw::c_uchar,
    pub iTermOffset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sqlite3_index_info_sqlite3_index_constraint() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_index_info_sqlite3_index_constraint>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_index_info_sqlite3_index_constraint>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_constraint>())).iColumn
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint),
            "::",
            stringify!(iColumn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_constraint>())).op as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_constraint>())).usable
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint),
            "::",
            stringify!(usable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_constraint>())).iTermOffset
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint),
            "::",
            stringify!(iTermOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_info_sqlite3_index_orderby {
    pub iColumn: ::std::os::raw::c_int,
    pub desc: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_sqlite3_index_info_sqlite3_index_orderby() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_index_info_sqlite3_index_orderby>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sqlite3_index_info_sqlite3_index_orderby)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_index_info_sqlite3_index_orderby>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sqlite3_index_info_sqlite3_index_orderby)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_orderby>())).iColumn as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_orderby),
            "::",
            stringify!(iColumn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_orderby>())).desc as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_orderby),
            "::",
            stringify!(desc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_index_info_sqlite3_index_constraint_usage {
    pub argvIndex: ::std::os::raw::c_int,
    pub omit: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_sqlite3_index_info_sqlite3_index_constraint_usage() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_index_info_sqlite3_index_constraint_usage>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint_usage)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_index_info_sqlite3_index_constraint_usage>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_constraint_usage>())).argvIndex
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint_usage),
            "::",
            stringify!(argvIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info_sqlite3_index_constraint_usage>())).omit
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info_sqlite3_index_constraint_usage),
            "::",
            stringify!(omit)
        )
    );
}
#[test]
fn bindgen_test_layout_sqlite3_index_info() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_index_info>(),
        96usize,
        concat!("Size of: ", stringify!(sqlite3_index_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_index_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_index_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).nConstraint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(nConstraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).aConstraint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(aConstraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).nOrderBy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(nOrderBy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).aOrderBy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(aOrderBy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info>())).aConstraintUsage as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(aConstraintUsage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).idxNum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(idxNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).idxStr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(idxStr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info>())).needToFreeIdxStr as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(needToFreeIdxStr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info>())).orderByConsumed as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(orderByConsumed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info>())).estimatedCost as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(estimatedCost)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_index_info>())).estimatedRows as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(estimatedRows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).idxFlags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(idxFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_index_info>())).colUsed as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_index_info),
            "::",
            stringify!(colUsed)
        )
    );
}
extern "C" {
    pub fn sqlite3_create_module(
        db: *mut sqlite3,
        zName: *const ::std::os::raw::c_char,
        p: *const sqlite3_module,
        pClientData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_create_module_v2(
        db: *mut sqlite3,
        zName: *const ::std::os::raw::c_char,
        p: *const sqlite3_module,
        pClientData: *mut ::std::os::raw::c_void,
        xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_drop_modules(
        db: *mut sqlite3,
        azKeep: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_vtab {
    pub pModule: *const sqlite3_module,
    pub nRef: ::std::os::raw::c_int,
    pub zErrMsg: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_sqlite3_vtab() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_vtab>(),
        24usize,
        concat!("Size of: ", stringify!(sqlite3_vtab))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_vtab>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_vtab))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vtab>())).pModule as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vtab),
            "::",
            stringify!(pModule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vtab>())).nRef as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vtab),
            "::",
            stringify!(nRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vtab>())).zErrMsg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vtab),
            "::",
            stringify!(zErrMsg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_vtab_cursor {
    pub pVtab: *mut sqlite3_vtab,
}
#[test]
fn bindgen_test_layout_sqlite3_vtab_cursor() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_vtab_cursor>(),
        8usize,
        concat!("Size of: ", stringify!(sqlite3_vtab_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_vtab_cursor>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_vtab_cursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_vtab_cursor>())).pVtab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_vtab_cursor),
            "::",
            stringify!(pVtab)
        )
    );
}
extern "C" {
    pub fn sqlite3_declare_vtab(
        arg1: *mut sqlite3,
        zSQL: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_overload_function(
        arg1: *mut sqlite3,
        zFuncName: *const ::std::os::raw::c_char,
        nArg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_blob {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sqlite3_blob_open(
        arg1: *mut sqlite3,
        zDb: *const ::std::os::raw::c_char,
        zTable: *const ::std::os::raw::c_char,
        zColumn: *const ::std::os::raw::c_char,
        iRow: sqlite3_int64,
        flags: ::std::os::raw::c_int,
        ppBlob: *mut *mut sqlite3_blob,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_blob_reopen(
        arg1: *mut sqlite3_blob,
        arg2: sqlite3_int64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_blob_close(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_blob_bytes(arg1: *mut sqlite3_blob) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_blob_read(
        arg1: *mut sqlite3_blob,
        Z: *mut ::std::os::raw::c_void,
        N: ::std::os::raw::c_int,
        iOffset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_blob_write(
        arg1: *mut sqlite3_blob,
        z: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        iOffset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vfs_find(zVfsName: *const ::std::os::raw::c_char) -> *mut sqlite3_vfs;
}
extern "C" {
    pub fn sqlite3_vfs_register(
        arg1: *mut sqlite3_vfs,
        makeDflt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vfs_unregister(arg1: *mut sqlite3_vfs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_mutex_alloc(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex;
}
extern "C" {
    pub fn sqlite3_mutex_free(arg1: *mut sqlite3_mutex);
}
extern "C" {
    pub fn sqlite3_mutex_enter(arg1: *mut sqlite3_mutex);
}
extern "C" {
    pub fn sqlite3_mutex_try(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_mutex_leave(arg1: *mut sqlite3_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_mutex_methods {
    pub xMutexInit: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub xMutexEnd: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub xMutexAlloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut sqlite3_mutex,
    >,
    pub xMutexFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub xMutexEnter: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub xMutexTry: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,
    >,
    pub xMutexLeave: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
    pub xMutexHeld: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,
    >,
    pub xMutexNotheld: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_sqlite3_mutex_methods() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_mutex_methods>(),
        72usize,
        concat!("Size of: ", stringify!(sqlite3_mutex_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_mutex_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_mutex_methods))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexInit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexEnd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexEnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexAlloc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexAlloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexFree as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexFree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexEnter as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexEnter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexTry as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexTry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexLeave as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexLeave)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexHeld as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexHeld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_mutex_methods>())).xMutexNotheld as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_mutex_methods),
            "::",
            stringify!(xMutexNotheld)
        )
    );
}
extern "C" {
    pub fn sqlite3_mutex_held(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_mutex_notheld(arg1: *mut sqlite3_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_db_mutex(arg1: *mut sqlite3) -> *mut sqlite3_mutex;
}
extern "C" {
    pub fn sqlite3_file_control(
        arg1: *mut sqlite3,
        zDbName: *const ::std::os::raw::c_char,
        op: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_test_control(op: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_keyword_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_keyword_name(
        arg1: ::std::os::raw::c_int,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_keyword_check(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_str {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sqlite3_str_new(arg1: *mut sqlite3) -> *mut sqlite3_str;
}
extern "C" {
    pub fn sqlite3_str_finish(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_str_appendf(arg1: *mut sqlite3_str, zFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn sqlite3_str_vappendf(
        arg1: *mut sqlite3_str,
        zFormat: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn sqlite3_str_append(
        arg1: *mut sqlite3_str,
        zIn: *const ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sqlite3_str_appendall(arg1: *mut sqlite3_str, zIn: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sqlite3_str_appendchar(
        arg1: *mut sqlite3_str,
        N: ::std::os::raw::c_int,
        C: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn sqlite3_str_reset(arg1: *mut sqlite3_str);
}
extern "C" {
    pub fn sqlite3_str_errcode(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_str_length(arg1: *mut sqlite3_str) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_str_value(arg1: *mut sqlite3_str) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_status(
        op: ::std::os::raw::c_int,
        pCurrent: *mut ::std::os::raw::c_int,
        pHighwater: *mut ::std::os::raw::c_int,
        resetFlag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_status64(
        op: ::std::os::raw::c_int,
        pCurrent: *mut sqlite3_int64,
        pHighwater: *mut sqlite3_int64,
        resetFlag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_db_status(
        arg1: *mut sqlite3,
        op: ::std::os::raw::c_int,
        pCur: *mut ::std::os::raw::c_int,
        pHiwtr: *mut ::std::os::raw::c_int,
        resetFlg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_stmt_status(
        arg1: *mut sqlite3_stmt,
        op: ::std::os::raw::c_int,
        resetFlg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache_page {
    pub pBuf: *mut ::std::os::raw::c_void,
    pub pExtra: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sqlite3_pcache_page() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_pcache_page>(),
        16usize,
        concat!("Size of: ", stringify!(sqlite3_pcache_page))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_pcache_page>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_pcache_page))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_page>())).pBuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_page),
            "::",
            stringify!(pBuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_page>())).pExtra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_page),
            "::",
            stringify!(pExtra)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache_methods2 {
    pub iVersion: ::std::os::raw::c_int,
    pub pArg: *mut ::std::os::raw::c_void,
    pub xInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xShutdown: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            szPage: ::std::os::raw::c_int,
            szExtra: ::std::os::raw::c_int,
            bPurgeable: ::std::os::raw::c_int,
        ) -> *mut sqlite3_pcache,
    >,
    pub xCachesize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),
    >,
    pub xPagecount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> ::std::os::raw::c_int,
    >,
    pub xFetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            key: ::std::os::raw::c_uint,
            createFlag: ::std::os::raw::c_int,
        ) -> *mut sqlite3_pcache_page,
    >,
    pub xUnpin: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut sqlite3_pcache_page,
            discard: ::std::os::raw::c_int,
        ),
    >,
    pub xRekey: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut sqlite3_pcache_page,
            oldKey: ::std::os::raw::c_uint,
            newKey: ::std::os::raw::c_uint,
        ),
    >,
    pub xTruncate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),
    >,
    pub xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
    pub xShrink: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
}
#[test]
fn bindgen_test_layout_sqlite3_pcache_methods2() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_pcache_methods2>(),
        104usize,
        concat!("Size of: ", stringify!(sqlite3_pcache_methods2))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_pcache_methods2>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_pcache_methods2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).iVersion as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(iVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).pArg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(pArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xInit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xShutdown as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xShutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xCreate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xCreate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xCachesize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xCachesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xPagecount as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xPagecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xFetch as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xFetch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xUnpin as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xUnpin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xRekey as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xRekey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xTruncate as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xTruncate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xDestroy as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xDestroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods2>())).xShrink as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods2),
            "::",
            stringify!(xShrink)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_pcache_methods {
    pub pArg: *mut ::std::os::raw::c_void,
    pub xInit: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub xShutdown: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            szPage: ::std::os::raw::c_int,
            bPurgeable: ::std::os::raw::c_int,
        ) -> *mut sqlite3_pcache,
    >,
    pub xCachesize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),
    >,
    pub xPagecount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> ::std::os::raw::c_int,
    >,
    pub xFetch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            key: ::std::os::raw::c_uint,
            createFlag: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xUnpin: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut ::std::os::raw::c_void,
            discard: ::std::os::raw::c_int,
        ),
    >,
    pub xRekey: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sqlite3_pcache,
            arg2: *mut ::std::os::raw::c_void,
            oldKey: ::std::os::raw::c_uint,
            newKey: ::std::os::raw::c_uint,
        ),
    >,
    pub xTruncate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),
    >,
    pub xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
}
#[test]
fn bindgen_test_layout_sqlite3_pcache_methods() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_pcache_methods>(),
        88usize,
        concat!("Size of: ", stringify!(sqlite3_pcache_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_pcache_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_pcache_methods))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods>())).pArg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(pArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xInit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xShutdown as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xShutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xCreate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xCreate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xCachesize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xCachesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xPagecount as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xPagecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xFetch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xFetch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xUnpin as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xUnpin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xRekey as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xRekey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xTruncate as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xTruncate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_pcache_methods>())).xDestroy as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_pcache_methods),
            "::",
            stringify!(xDestroy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_backup {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sqlite3_backup_init(
        pDest: *mut sqlite3,
        zDestName: *const ::std::os::raw::c_char,
        pSource: *mut sqlite3,
        zSourceName: *const ::std::os::raw::c_char,
    ) -> *mut sqlite3_backup;
}
extern "C" {
    pub fn sqlite3_backup_step(
        p: *mut sqlite3_backup,
        nPage: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_backup_remaining(p: *mut sqlite3_backup) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_backup_pagecount(p: *mut sqlite3_backup) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_unlock_notify(
        pBlocked: *mut sqlite3,
        xNotify: ::std::option::Option<
            unsafe extern "C" fn(
                apArg: *mut *mut ::std::os::raw::c_void,
                nArg: ::std::os::raw::c_int,
            ),
        >,
        pNotifyArg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_stricmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_strnicmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_strglob(
        zGlob: *const ::std::os::raw::c_char,
        zStr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_strlike(
        zGlob: *const ::std::os::raw::c_char,
        zStr: *const ::std::os::raw::c_char,
        cEsc: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_log(
        iErrCode: ::std::os::raw::c_int,
        zFormat: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn sqlite3_wal_hook(
        arg1: *mut sqlite3,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut sqlite3,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sqlite3_wal_autocheckpoint(
        db: *mut sqlite3,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_wal_checkpoint(
        db: *mut sqlite3,
        zDb: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_wal_checkpoint_v2(
        db: *mut sqlite3,
        zDb: *const ::std::os::raw::c_char,
        eMode: ::std::os::raw::c_int,
        pnLog: *mut ::std::os::raw::c_int,
        pnCkpt: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_config(
        arg1: *mut sqlite3,
        op: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_on_conflict(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_nochange(arg1: *mut sqlite3_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_collation(
        arg1: *mut sqlite3_index_info,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sqlite3_vtab_distinct(arg1: *mut sqlite3_index_info) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_in(
        arg1: *mut sqlite3_index_info,
        iCons: ::std::os::raw::c_int,
        bHandle: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_in_first(
        pVal: *mut sqlite3_value,
        ppOut: *mut *mut sqlite3_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_in_next(
        pVal: *mut sqlite3_value,
        ppOut: *mut *mut sqlite3_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_vtab_rhs_value(
        arg1: *mut sqlite3_index_info,
        arg2: ::std::os::raw::c_int,
        ppVal: *mut *mut sqlite3_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_stmt_scanstatus(
        pStmt: *mut sqlite3_stmt,
        idx: ::std::os::raw::c_int,
        iScanStatusOp: ::std::os::raw::c_int,
        pOut: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_stmt_scanstatus_reset(arg1: *mut sqlite3_stmt);
}
extern "C" {
    pub fn sqlite3_db_cacheflush(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_system_errno(arg1: *mut sqlite3) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sqlite3_snapshot {
    pub hidden: [::std::os::raw::c_uchar; 48usize],
}
#[test]
fn bindgen_test_layout_sqlite3_snapshot() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_snapshot>(),
        48usize,
        concat!("Size of: ", stringify!(sqlite3_snapshot))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_snapshot>(),
        1usize,
        concat!("Alignment of ", stringify!(sqlite3_snapshot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_snapshot>())).hidden as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_snapshot),
            "::",
            stringify!(hidden)
        )
    );
}
extern "C" {
    pub fn sqlite3_snapshot_get(
        db: *mut sqlite3,
        zSchema: *const ::std::os::raw::c_char,
        ppSnapshot: *mut *mut sqlite3_snapshot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_snapshot_open(
        db: *mut sqlite3,
        zSchema: *const ::std::os::raw::c_char,
        pSnapshot: *mut sqlite3_snapshot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_snapshot_free(arg1: *mut sqlite3_snapshot);
}
extern "C" {
    pub fn sqlite3_snapshot_cmp(
        p1: *mut sqlite3_snapshot,
        p2: *mut sqlite3_snapshot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_snapshot_recover(
        db: *mut sqlite3,
        zDb: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sqlite3_serialize(
        db: *mut sqlite3,
        zSchema: *const ::std::os::raw::c_char,
        piSize: *mut sqlite3_int64,
        mFlags: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn sqlite3_deserialize(
        db: *mut sqlite3,
        zSchema: *const ::std::os::raw::c_char,
        pData: *mut ::std::os::raw::c_uchar,
        szDb: sqlite3_int64,
        szBuf: sqlite3_int64,
        mFlags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type sqlite3_rtree_dbl = f64;
extern "C" {
    pub fn sqlite3_rtree_geometry_callback(
        db: *mut sqlite3,
        zGeom: *const ::std::os::raw::c_char,
        xGeom: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sqlite3_rtree_geometry,
                arg2: ::std::os::raw::c_int,
                arg3: *mut sqlite3_rtree_dbl,
                arg4: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        pContext: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_rtree_geometry {
    pub pContext: *mut ::std::os::raw::c_void,
    pub nParam: ::std::os::raw::c_int,
    pub aParam: *mut sqlite3_rtree_dbl,
    pub pUser: *mut ::std::os::raw::c_void,
    pub xDelUser: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_sqlite3_rtree_geometry() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_rtree_geometry>(),
        40usize,
        concat!("Size of: ", stringify!(sqlite3_rtree_geometry))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_rtree_geometry>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_rtree_geometry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_geometry>())).pContext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_geometry),
            "::",
            stringify!(pContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_geometry>())).nParam as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_geometry),
            "::",
            stringify!(nParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_geometry>())).aParam as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_geometry),
            "::",
            stringify!(aParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_geometry>())).pUser as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_geometry),
            "::",
            stringify!(pUser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_geometry>())).xDelUser as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_geometry),
            "::",
            stringify!(xDelUser)
        )
    );
}
extern "C" {
    pub fn sqlite3_rtree_query_callback(
        db: *mut sqlite3,
        zQueryFunc: *const ::std::os::raw::c_char,
        xQueryFunc: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut sqlite3_rtree_query_info) -> ::std::os::raw::c_int,
        >,
        pContext: *mut ::std::os::raw::c_void,
        xDestructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_rtree_query_info {
    pub pContext: *mut ::std::os::raw::c_void,
    pub nParam: ::std::os::raw::c_int,
    pub aParam: *mut sqlite3_rtree_dbl,
    pub pUser: *mut ::std::os::raw::c_void,
    pub xDelUser: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub aCoord: *mut sqlite3_rtree_dbl,
    pub anQueue: *mut ::std::os::raw::c_uint,
    pub nCoord: ::std::os::raw::c_int,
    pub iLevel: ::std::os::raw::c_int,
    pub mxLevel: ::std::os::raw::c_int,
    pub iRowid: sqlite3_int64,
    pub rParentScore: sqlite3_rtree_dbl,
    pub eParentWithin: ::std::os::raw::c_int,
    pub eWithin: ::std::os::raw::c_int,
    pub rScore: sqlite3_rtree_dbl,
    pub apSqlParam: *mut *mut sqlite3_value,
}
#[test]
fn bindgen_test_layout_sqlite3_rtree_query_info() {
    assert_eq!(
        ::std::mem::size_of::<sqlite3_rtree_query_info>(),
        112usize,
        concat!("Size of: ", stringify!(sqlite3_rtree_query_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sqlite3_rtree_query_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sqlite3_rtree_query_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).pContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(pContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).nParam as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(nParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).aParam as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(aParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).pUser as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(pUser)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).xDelUser as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(xDelUser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).aCoord as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(aCoord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).anQueue as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(anQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).nCoord as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(nCoord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).iLevel as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(iLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).mxLevel as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(mxLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).iRowid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(iRowid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).rParentScore as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(rParentScore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).eParentWithin as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(eParentWithin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).eWithin as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(eWithin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).rScore as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(rScore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sqlite3_rtree_query_info>())).apSqlParam as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sqlite3_rtree_query_info),
            "::",
            stringify!(apSqlParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5Context {
    _unused: [u8; 0],
}
pub type fts5_extension_function = ::std::option::Option<
    unsafe extern "C" fn(
        pApi: *const Fts5ExtensionApi,
        pFts: *mut Fts5Context,
        pCtx: *mut sqlite3_context,
        nVal: ::std::os::raw::c_int,
        apVal: *mut *mut sqlite3_value,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5PhraseIter {
    pub a: *const ::std::os::raw::c_uchar,
    pub b: *const ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_Fts5PhraseIter() {
    assert_eq!(
        ::std::mem::size_of::<Fts5PhraseIter>(),
        16usize,
        concat!("Size of: ", stringify!(Fts5PhraseIter))
    );
    assert_eq!(
        ::std::mem::align_of::<Fts5PhraseIter>(),
        8usize,
        concat!("Alignment of ", stringify!(Fts5PhraseIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5PhraseIter>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5PhraseIter),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5PhraseIter>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5PhraseIter),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5ExtensionApi {
    pub iVersion: ::std::os::raw::c_int,
    pub xUserData: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut Fts5Context) -> *mut ::std::os::raw::c_void,
    >,
    pub xColumnCount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut Fts5Context) -> ::std::os::raw::c_int,
    >,
    pub xRowCount: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pnRow: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xColumnTotalSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iCol: ::std::os::raw::c_int,
            pnToken: *mut sqlite3_int64,
        ) -> ::std::os::raw::c_int,
    >,
    pub xTokenize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pText: *const ::std::os::raw::c_char,
            nText: ::std::os::raw::c_int,
            pCtx: *mut ::std::os::raw::c_void,
            xToken: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: ::std::os::raw::c_int,
                    arg5: ::std::os::raw::c_int,
                    arg6: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub xPhraseCount: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut Fts5Context) -> ::std::os::raw::c_int,
    >,
    pub xPhraseSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xInstCount: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pnInst: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xInst: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iIdx: ::std::os::raw::c_int,
            piPhrase: *mut ::std::os::raw::c_int,
            piCol: *mut ::std::os::raw::c_int,
            piOff: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xRowid:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut Fts5Context) -> sqlite3_int64>,
    pub xColumnText: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iCol: ::std::os::raw::c_int,
            pz: *mut *const ::std::os::raw::c_char,
            pn: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xColumnSize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iCol: ::std::os::raw::c_int,
            pnToken: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xQueryPhrase: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
            pUserData: *mut ::std::os::raw::c_void,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const Fts5ExtensionApi,
                    arg2: *mut Fts5Context,
                    arg3: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
    pub xSetAuxdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            pAux: *mut ::std::os::raw::c_void,
            xDelete: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub xGetAuxdata: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            bClear: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub xPhraseFirst: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
            arg2: *mut Fts5PhraseIter,
            arg3: *mut ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xPhraseNext: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            arg2: *mut Fts5PhraseIter,
            piCol: *mut ::std::os::raw::c_int,
            piOff: *mut ::std::os::raw::c_int,
        ),
    >,
    pub xPhraseFirstColumn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            iPhrase: ::std::os::raw::c_int,
            arg2: *mut Fts5PhraseIter,
            arg3: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub xPhraseNextColumn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Context,
            arg2: *mut Fts5PhraseIter,
            piCol: *mut ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_Fts5ExtensionApi() {
    assert_eq!(
        ::std::mem::size_of::<Fts5ExtensionApi>(),
        160usize,
        concat!("Size of: ", stringify!(Fts5ExtensionApi))
    );
    assert_eq!(
        ::std::mem::align_of::<Fts5ExtensionApi>(),
        8usize,
        concat!("Alignment of ", stringify!(Fts5ExtensionApi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).iVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(iVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xUserData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xColumnCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xColumnCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xRowCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xRowCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Fts5ExtensionApi>())).xColumnTotalSize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xColumnTotalSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xTokenize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xTokenize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xPhraseCount as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xPhraseCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xPhraseSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xPhraseSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xInstCount as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xInstCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xInst as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xInst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xRowid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xRowid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xColumnText as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xColumnText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xColumnSize as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xColumnSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xQueryPhrase as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xQueryPhrase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xSetAuxdata as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xSetAuxdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xGetAuxdata as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xGetAuxdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xPhraseFirst as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xPhraseFirst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Fts5ExtensionApi>())).xPhraseNext as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xPhraseNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Fts5ExtensionApi>())).xPhraseFirstColumn as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xPhraseFirstColumn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Fts5ExtensionApi>())).xPhraseNextColumn as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Fts5ExtensionApi),
            "::",
            stringify!(xPhraseNextColumn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fts5Tokenizer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fts5_tokenizer {
    pub xCreate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            azArg: *mut *const ::std::os::raw::c_char,
            nArg: ::std::os::raw::c_int,
            ppOut: *mut *mut Fts5Tokenizer,
        ) -> ::std::os::raw::c_int,
    >,
    pub xDelete: ::std::option::Option<unsafe extern "C" fn(arg1: *mut Fts5Tokenizer)>,
    pub xTokenize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Fts5Tokenizer,
            pCtx: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
            pText: *const ::std::os::raw::c_char,
            nText: ::std::os::raw::c_int,
            xToken: ::std::option::Option<
                unsafe extern "C" fn(
                    pCtx: *mut ::std::os::raw::c_void,
                    tflags: ::std::os::raw::c_int,
                    pToken: *const ::std::os::raw::c_char,
                    nToken: ::std::os::raw::c_int,
                    iStart: ::std::os::raw::c_int,
                    iEnd: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_fts5_tokenizer() {
    assert_eq!(
        ::std::mem::size_of::<fts5_tokenizer>(),
        24usize,
        concat!("Size of: ", stringify!(fts5_tokenizer))
    );
    assert_eq!(
        ::std::mem::align_of::<fts5_tokenizer>(),
        8usize,
        concat!("Alignment of ", stringify!(fts5_tokenizer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fts5_tokenizer>())).xCreate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fts5_tokenizer),
            "::",
            stringify!(xCreate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fts5_tokenizer>())).xDelete as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fts5_tokenizer),
            "::",
            stringify!(xDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fts5_tokenizer>())).xTokenize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fts5_tokenizer),
            "::",
            stringify!(xTokenize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fts5_api {
    pub iVersion: ::std::os::raw::c_int,
    pub xCreateTokenizer: ::std::option::Option<
        unsafe extern "C" fn(
            pApi: *mut fts5_api,
            zName: *const ::std::os::raw::c_char,
            pContext: *mut ::std::os::raw::c_void,
            pTokenizer: *mut fts5_tokenizer,
            xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub xFindTokenizer: ::std::option::Option<
        unsafe extern "C" fn(
            pApi: *mut fts5_api,
            zName: *const ::std::os::raw::c_char,
            ppContext: *mut *mut ::std::os::raw::c_void,
            pTokenizer: *mut fts5_tokenizer,
        ) -> ::std::os::raw::c_int,
    >,
    pub xCreateFunction: ::std::option::Option<
        unsafe extern "C" fn(
            pApi: *mut fts5_api,
            zName: *const ::std::os::raw::c_char,
            pContext: *mut ::std::os::raw::c_void,
            xFunction: fts5_extension_function,
            xDestroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_fts5_api() {
    assert_eq!(
        ::std::mem::size_of::<fts5_api>(),
        32usize,
        concat!("Size of: ", stringify!(fts5_api))
    );
    assert_eq!(
        ::std::mem::align_of::<fts5_api>(),
        8usize,
        concat!("Alignment of ", stringify!(fts5_api))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fts5_api>())).iVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fts5_api),
            "::",
            stringify!(iVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fts5_api>())).xCreateTokenizer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fts5_api),
            "::",
            stringify!(xCreateTokenizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fts5_api>())).xFindTokenizer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fts5_api),
            "::",
            stringify!(xFindTokenizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fts5_api>())).xCreateFunction as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fts5_api),
            "::",
            stringify!(xCreateFunction)
        )
    );
}
pub const DBWType_DBW_INTEGER: DBWType = 0;
pub const DBWType_DBW_UNKN: DBWType = 1;
pub type DBWType = u32;
pub const DBWResType_DBW_TUPLES: DBWResType = 0;
pub const DBWResType_DBW_TYPES: DBWResType = 1;
pub type DBWResType = u32;
pub const DBWError_DBW_OK: DBWError = 0;
pub const DBWError_DBW_ERR: DBWError = -1;
pub const DBWError_DBW_ERR_NOT_FOUND: DBWError = -2;
pub const DBWError_DBW_ERR_UNKN_DB: DBWError = -3;
pub const DBWError_DBW_ERR_ALREADY_EXISTS: DBWError = -4;
pub type DBWError = i32;
pub use self::DBWError as DBWDBError;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DBWResult {
    pub res_type: ::std::os::raw::c_int,
    pub head_vec: DBWResult__bindgen_ty_1,
    pub __bindgen_anon_1: DBWResult__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DBWResult__bindgen_ty_1 {
    pub n: size_t,
    pub m: size_t,
    pub a: *mut bstring,
}
#[test]
fn bindgen_test_layout_DBWResult__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<DBWResult__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(DBWResult__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<DBWResult__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(DBWResult__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWResult__bindgen_ty_1>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_1),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWResult__bindgen_ty_1>())).m as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_1),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWResult__bindgen_ty_1>())).a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_1),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DBWResult__bindgen_ty_2 {
    pub res_vec: DBWResult__bindgen_ty_2__bindgen_ty_1,
    pub types_vec: DBWResult__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DBWResult__bindgen_ty_2__bindgen_ty_1 {
    pub n: size_t,
    pub m: size_t,
    pub a: *mut bstring,
}
#[test]
fn bindgen_test_layout_DBWResult__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<DBWResult__bindgen_ty_2__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DBWResult__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DBWResult__bindgen_ty_2__bindgen_ty_1>())).n as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DBWResult__bindgen_ty_2__bindgen_ty_1>())).m as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DBWResult__bindgen_ty_2__bindgen_ty_1>())).a as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DBWResult__bindgen_ty_2__bindgen_ty_2 {
    pub n: size_t,
    pub m: size_t,
    pub a: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DBWResult__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<DBWResult__bindgen_ty_2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DBWResult__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DBWResult__bindgen_ty_2__bindgen_ty_2>())).n as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DBWResult__bindgen_ty_2__bindgen_ty_2>())).m as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DBWResult__bindgen_ty_2__bindgen_ty_2>())).a as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(a)
        )
    );
}
#[test]
fn bindgen_test_layout_DBWResult__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<DBWResult__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(DBWResult__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<DBWResult__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(DBWResult__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWResult__bindgen_ty_2>())).res_vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2),
            "::",
            stringify!(res_vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DBWResult__bindgen_ty_2>())).types_vec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult__bindgen_ty_2),
            "::",
            stringify!(types_vec)
        )
    );
}
#[test]
fn bindgen_test_layout_DBWResult() {
    assert_eq!(
        ::std::mem::size_of::<DBWResult>(),
        56usize,
        concat!("Size of: ", stringify!(DBWResult))
    );
    assert_eq!(
        ::std::mem::align_of::<DBWResult>(),
        8usize,
        concat!("Alignment of ", stringify!(DBWResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWResult>())).res_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult),
            "::",
            stringify!(res_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWResult>())).head_vec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWResult),
            "::",
            stringify!(head_vec)
        )
    );
}
pub const DBWDBType_DBW_POSTGRESQL: DBWDBType = 0;
pub const DBWDBType_DBW_SQLITE3: DBWDBType = 1;
pub type DBWDBType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DBWHandler {
    pub DBWDBType: ::std::os::raw::c_int,
    pub conn: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DBWHandler() {
    assert_eq!(
        ::std::mem::size_of::<DBWHandler>(),
        16usize,
        concat!("Size of: ", stringify!(DBWHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<DBWHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(DBWHandler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWHandler>())).DBWDBType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWHandler),
            "::",
            stringify!(DBWDBType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBWHandler>())).conn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBWHandler),
            "::",
            stringify!(conn)
        )
    );
}
extern "C" {
    pub fn dbw_connect(
        DBWDBType: DBWDBType,
        url: bstring,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut DBWHandler;
}
extern "C" {
    pub fn dbw_get_table_types(
        h: *mut DBWHandler,
        table: bstring,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut DBWResult;
}
extern "C" {
    pub fn dbw_query(
        h: *mut DBWHandler,
        query: bstring,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut DBWResult;
}
extern "C" {
    pub fn dbw_close(h: *mut DBWHandler) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dbw_print(res: *mut DBWResult) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DBWResult_destroy(res: *mut DBWResult) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dbw_new_snippet(
        h: *mut DBWHandler,
        title: bstring,
        snippet: bstring,
        type_: bstring,
        tags: *const bstrListEmb,
        err: *mut ::std::os::raw::c_int,
    ) -> sqlite_int64;
}
extern "C" {
    pub fn dbw_find_snippets(
        h: *mut DBWHandler,
        title: bstring,
        type_: bstring,
        tags: *const bstrListEmb,
        ret_err: *mut ::std::os::raw::c_int,
    ) -> bstring;
}
extern "C" {
    pub fn dbw_get_snippet(h: *mut DBWHandler, id: sqlite_int64, err: *mut DBWError) -> bstring;
}
extern "C" {
    pub fn dbw_edit_snippet(
        h: *mut DBWHandler,
        id: sqlite_int64,
        title: bstring,
        snippet: bstring,
        type_: bstring,
        tags: *const bstrListEmb,
        deleted: ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> sqlite_int64;
}
extern "C" {
    pub fn dbw_register_file(
        h: *mut DBWHandler,
        filename: bstring,
        location: bstring,
        type_: bstring,
        tags: *const bstrListEmb,
        err: *mut ::std::os::raw::c_int,
    ) -> sqlite_int64;
}
extern "C" {
    pub fn json_api_create_snippet(
        db_handle: *mut DBWHandler,
        json_req: bstring,
        snippet_id: sqlite_int64,
        edit: ::std::os::raw::c_int,
        ec: *mut ::std::os::raw::c_int,
    ) -> bstring;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
